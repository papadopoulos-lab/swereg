[{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"project-overview","dir":"","previous_headings":"","what":"Project overview","title":"CLAUDE.md","text":"swereg R package manipulating analyzing Swedish healthcare registry data epidemiological research. creates longitudinal data skeletons ISO year-week structure integrates multiple Swedish health registries (NPR, LMED, Cause Death). package optimized gender dysphoria research works general registry analysis.","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"core-development-workflow","dir":"","previous_headings":"Development commands","what":"Core development workflow","title":"CLAUDE.md","text":"","code":"# Load package functions during development devtools::load_all(\".\")  # Generate documentation devtools::document()  # Check package integrity (includes tests, examples, documentation) devtools::check()  # Alternative: Use R CMD check (more comprehensive, CRAN-style) R CMD check .  # Build and install devtools::build() devtools::install()"},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"testing-and-development-scripts","dir":"","previous_headings":"Development commands","what":"Testing and development scripts","title":"CLAUDE.md","text":"","code":"# Generate fake data (run once or when data structure changes) source(\"dev/generate_fake_data.R\")  # Quick functionality test source(\"dev/quick_test.R\")  # Full workflow test with all features source(\"dev/test_with_fake_data.R\")  # Memory-efficient batched workflow (production-style) source(\"dev/workflow_batched_memory_efficient.R\")  # Load required libraries for manual testing library(data.table) devtools::load_all(\".\")"},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"three-stage-workflow-pattern","dir":"","previous_headings":"Architecture and data flow","what":"Three-stage workflow pattern","title":"CLAUDE.md","text":"swereg follows systematic three-stage approach (“Good Bones, Muscles”): skeleton1_create: Raw data integration - Create time skeleton merge registry data skeleton2_clean: Data cleaning derived variables - Clean process within skeleton skeleton3_analyze: Analysis-ready dataset preparation - Final analysis preparation","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"core-pattern-longitudinal-skeleton--sequential-data-integration","dir":"","previous_headings":"Architecture and data flow","what":"Core pattern: longitudinal skeleton + sequential data integration","title":"CLAUDE.md","text":"Skeleton Creation: create_skeleton() builds time-structured framework individual IDs ISO weeks Sequential Data Addition: Use specialized functions add different data types data.table Optimization: operations use data.table efficient processing large datasets","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"key-integration-functions-in-typical-order-of-use","dir":"","previous_headings":"Architecture and data flow","what":"Key integration functions (in typical order of use)","title":"CLAUDE.md","text":"add_onetime() - Baseline/demographic data (one record per person) add_annual() - Annual data specific years (e.g., socioeconomic status) add_diagnoses() - NPR diagnosis data ICD-10 codes (hospital visits) add_operations() - Surgical procedure codes NPR add_rx() - LMED prescription data ATC codes treatment periods add_cods() - Cause death information","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"swedish-registry-context","dir":"","previous_headings":"Architecture and data flow","what":"Swedish registry context","title":"CLAUDE.md","text":"NPR (National Patient Register): Specialist healthcare (inpatient sv outpatient ov) LMED (Prescribed Drug Register): Prescription medications ATC codes SCB (Statistics Sweden): Demographics socioeconomic data Cause Death Register: Mortality data ICD-10 codes Uses cstime package Swedish ISO time standards","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"always-apply-make_lowercase_names-with-date-cleaning","dir":"","previous_headings":"Critical data processing rules","what":"Always apply make_lowercase_names() with date cleaning","title":"CLAUDE.md","text":"ESSENTIAL: imported data must processed swereg::make_lowercase_names() use. Now includes automatic date cleaning: transforms column names like LopNr → lopnr, ATC → atc, INDATUM → indatum, converts specified date columns Date class.","code":"# Read data data <- fread(\"file.txt\")  # or haven::read_sas() etc.  # REQUIRED: Apply lowercase transformation with date cleaning swereg::make_lowercase_names(data, date_column = \"INDATUM\")  # Now safe to use with swereg functions - note that a 'date' column is created swereg::add_diagnoses(skeleton, data, id_name = \"lopnr\", ...)"},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"swedish-date-parsing","dir":"","previous_headings":"Critical data processing rules","what":"Swedish date parsing","title":"CLAUDE.md","text":"Swedish registry dates come different precision levels. make_lowercase_names() function date_columns parameter handles: Date format handling: - 4 characters (YYYY): Year → adds July 1st default - 6 characters (YYYYMM): Year-month → adds 15th default - 8 characters (YYYYMMDD): Full date → uses -- Special cases: “0000” → “0701”, “00” → “15”","code":"# Apply make_lowercase_names with date parsing swereg::make_lowercase_names(data, date_columns = \"INDATUM\")  # Custom defaults for missing date parts swereg::make_lowercase_names(data, date_columns = \"INDATUM\",                              default_month_day = \"0101\", default_day = \"01\")"},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"expected-column-names-after-make_lowercase_names","dir":"","previous_headings":"Critical data processing rules","what":"Expected column names after make_lowercase_names()","title":"CLAUDE.md","text":"Person IDs: lopnr (SCB), lopnr (NPR transformation), p444_lopnr_personnr (LMED) Dates: indatum (admission), utdatum (discharge), edatum (prescription), dodsdat (death) Note: Date columns converted Date class place date_columns parameter used Diagnosis codes: hdia (main), dia1, dia2, etc. (secondary), ekod1, etc. (external causes) Operation codes: op1, op2, etc. Prescription codes: atc (drug code), fddd (treatment duration)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"package-data-for-development","dir":"","previous_headings":"","what":"Package data for development","title":"CLAUDE.md","text":"package includes synthetic Swedish registry data development examples: - fake_demographics - SCB demographics (lopnr, fodelseman, DodDatum) - fake_annual_family - SCB annual family data (lopnr, FamTyp) - fake_inpatient_diagnoses - NPR inpatient data (full 43-column structure) - fake_outpatient_diagnoses - NPR outpatient data - fake_prescriptions - LMED prescription data (37 columns) - fake_cod - Cause death registry data - fake_person_ids - Reference list person identifiers Load : data(\"fake_demographics\") etc. Note: synthetic datasets designed replicate structure characteristics real Swedish registry data maintaining confidentiality privacy.","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"typical-analysis-workflow","dir":"","previous_headings":"Code patterns","what":"Typical analysis workflow","title":"CLAUDE.md","text":"","code":"# 1. Create skeleton (now includes personyears column) skeleton <- create_skeleton(ids, \"2001-01-01\", \"2020-12-31\")  # 2. Add baseline data demographics <- fread(\"demographics.csv\") swereg::make_lowercase_names(demographics, date_columns = \"FodelseMan\") add_onetime(skeleton, demographics, \"lopnr\")  # 3. Add longitudinal data hospital_data <- haven::read_sas(\"hospital.sas7bdat\") swereg::make_lowercase_names(hospital_data, date_columns = \"INDATUM\") add_diagnoses(skeleton, hospital_data, \"lopnr\", diags = list(   \"depression\" = c(\"^F32\", \"^F33\"),   \"anxiety\" = c(\"^F40\", \"^F41\") ))  # 4. Add prescriptions prescriptions <- fread(\"prescriptions.txt\") swereg::make_lowercase_names(prescriptions, date_columns = \"EDATUM\") add_rx(skeleton, prescriptions, \"lopnr\", drugs = list(   \"antidepressants\" = c(\"^N06A\") ))  # 5. Create rowind variables (skeleton2_clean phase) # Age at first depression diagnosis make_rowind_first_occurrence(skeleton,                             condition = \"depression == TRUE\",                             value_var = \"age\",                             new_var = \"rowind_age_first_depression\")  # Year of first antidepressant prescription   make_rowind_first_occurrence(skeleton,                             condition = \"antidepressants == TRUE\",                             value_var = \"isoyear\",                             new_var = \"rowind_isoyear_first_antidep\")"},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"pattern-matching-for-medical-codes","dir":"","previous_headings":"Code patterns","what":"Pattern matching for medical codes","title":"CLAUDE.md","text":"Regex patterns: Use ^ prefix exact starts (e.g., \"^F640\") Exclusions: Use ! prefix exclude (e.g., \"!F640\") Multiple patterns: Combine lists (e.g., c(\"^F640\", \"^F648\", \"^F649\")) Historical codes: ICD-9 uses [-Z] suffixes, ICD-8 uses comma delimiters","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"understanding-rowdep-vs-rowind-variables","dir":"","previous_headings":"Data Variable Types and Transformations","what":"Understanding rowdep vs rowind Variables","title":"CLAUDE.md","text":"longitudinal registry data analysis swereg, variables classified two fundamental types: rowdep (row-dependent): Variables can change time person rowind (row-independent): Variables change time person distinction crucial effective analysis, particularly skeleton2_clean phase many transformations convert rowdep variables rowind variables.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"examples-of-variable-types","dir":"","previous_headings":"Data Variable Types and Transformations","what":"Examples of Variable Types","title":"CLAUDE.md","text":"Row-dependent (rowdep) Variables: - rowdep_edu_cat: Education level (can improve time) - rowdep_income_inflation_adjusted: Annual income (changes yearly) - f64_diag: diagnosis week (TRUE/FALSE time period) - Current values vary isoyear/isoyearweek Row-independent (rowind) Variables: - rowind_age_first_gd: Age first diagnosis (fixed occurred) - rowind_isoyear_first_gd: Year first diagnosis (historical fact) - rowind_birthcountry: Birth country (never changes) - rowind_register_tag: Person’s role study (case, control, etc.) - rowind_age_death: Age death (fixed occurred)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"helper-function-make_rowind_first_occurrence","dir":"","previous_headings":"Data Variable Types and Transformations","what":"Helper Function: make_rowind_first_occurrence()","title":"CLAUDE.md","text":"make_rowind_first_occurrence() function simplifies common pattern creating row-independent variables first occurrence conditions: Function features: - Automatically handles temp variable creation cleanup - Uses first_non_na() robust aggregation across variable types - Includes comprehensive input validation clear error messages - Works condition can evaluated data.table syntax","code":"# Example: Create rowind variable for year of first F64 diagnosis make_rowind_first_occurrence(skeleton,                             condition = \"f64_diag == TRUE\",                             value_var = \"isoyear\",                              new_var = \"rowind_isoyear_first_f64\")  # More complex condition example make_rowind_first_occurrence(skeleton,                             condition = \"diag_gd_icd10_F64_089 == TRUE & is_amab == FALSE\",                             value_var = \"age\",                             new_var = \"rowind_age_first_gd_afab\")"},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"common-rowdep--rowind-transformation-patterns","dir":"","previous_headings":"Data Variable Types and Transformations","what":"Common rowdep → rowind Transformation Patterns","title":"CLAUDE.md","text":"","code":"# Manual pattern (traditional approach) skeleton[condition_is_true, temp := value_to_capture] skeleton[, new_rowind_var := first_non_na(temp), by = .(id)] skeleton[, temp := NULL]  # Helper function pattern (recommended) make_rowind_first_occurrence(skeleton, \"condition_is_true\", \"value_to_capture\", \"new_rowind_var\")"},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"integration-with-swereg-workflow","dir":"","previous_headings":"Data Variable Types and Transformations","what":"Integration with swereg Workflow","title":"CLAUDE.md","text":"rowdep/rowind concept fits standard swereg workflow: skeleton1_create: Focus data integration, creates mostly rowdep variables skeleton2_clean: Heavy focus rowdep → rowind transformations skeleton3_analyze: Work clean rowind variables analysis skeleton2_clean phase rowdep → rowind transformations occur, prepare stable person-level characteristics downstream analysis.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"naming-conventions","dir":"","previous_headings":"Data Variable Types and Transformations","what":"Naming Conventions","title":"CLAUDE.md","text":"Use rowdep_* prefix time-varying variables Use rowind_* prefix time-invariant variables descriptive: rowind_age_first_gd rowind_age Include context: rowind_isoyear_first_diagnosis rowind_year","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"best-practices","dir":"","previous_headings":"Data Variable Types and Transformations","what":"Best Practices","title":"CLAUDE.md","text":"Always validate rowind variables: detailed examples patterns, see “Understanding rowdep rowind Variables” vignette:","code":"# Check that rowind variables are actually row-independent skeleton[, .(unique_values = uniqueN(rowind_age_first_f64)), by = .(id)] # Should return 1 for all persons (all rows have same value) vignette(\"rowdep-rowind-concept\", package = \"swereg\")"},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"memory-efficient-batched-processing","dir":"","previous_headings":"Production workflow pattern","what":"Memory-efficient batched processing","title":"CLAUDE.md","text":"large datasets, use 3-phase batched approach helper functions example/R_generic_v002/:","code":"# Phase 1: Read large datasets once large_files <- read_large_files()  # Phase 2: Create skeleton1_create (compilation to skeleton format) # Process in batches to manage memory for(batch in batches) {   skeleton1_create(batch, ids_batch, large_files) } rm(large_files)  # Remove from RAM  # Phase 3: Create skeleton2_clean (clean variables using only skeleton data) for(batch in batches) {   skeleton2_clean(batch)  # Use only data within skeleton }"},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"production-example-scripts","dir":"","previous_headings":"Production workflow pattern","what":"Production example scripts","title":"CLAUDE.md","text":"example/ directory contains production-style workflow implementations: - example/R_generic_v002/ - Helper functions batched processing - example/Run_generic_v002.R - Main production workflow script - Individual project scripts showing real-world usage patterns Key principles: - Batch processing: Split individuals groups (e.g., 50-100 per batch) - Memory management: Remove large datasets skeleton1_create phase - Self-contained cleaning: skeleton2_clean uses data within skeleton","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"key-dependencies","dir":"","previous_headings":"","what":"Key dependencies","title":"CLAUDE.md","text":"Core: data.table, cstime, fs, stringr, dplyr, lubridate, havenDevelopment: devtools, usethis, testthat, ggplot2 Note: Package now uses base pipe |> instead magrittr %>% (requires R ≥ 4.1)","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"required-version-updates","dir":"","previous_headings":"Version control and release management","what":"REQUIRED: version updates","title":"CLAUDE.md","text":"Whenever code updated, following must done: ) Update version DESCRIPTION YY.M.D format (remove leading zeroes): B) Update NEWS.md changes:","code":"# Example: For January 5, 2025 Version: 25.1.5  # Example: For December 25, 2024   Version: 24.12.25 # swereg YY.M.D  ## Bug Fixes * Fixed issue with...  ## New Features   * Added function for...  ## Documentation * Updated vignette for..."},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"version-format-rules","dir":"","previous_headings":"Version control and release management","what":"Version format rules","title":"CLAUDE.md","text":"Use YY.M.D format (e.g., 25.1.5 25.01.05) Remove leading zeroes month day Update DESCRIPTION NEWS.md simultaneously Document user-facing changes NEWS.md","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"git-configuration-requirements","dir":"","previous_headings":"Version control and release management","what":"Git configuration requirements","title":"CLAUDE.md","text":"working repository, ensure git properly configured: Note: Adjust SSH key path working different environment. signing key point public SSH key file.","code":"# Required identity configuration git config --global user.email \"hello@rwhite.no\" git config --global user.name \"Richard Aubrey White\"  # Required signing configuration for security git config --global commit.gpgsign true git config --global gpg.format ssh git config --global user.signingkey ~/.ssh/id_ed25519.pub  # Required merge behavior git config --global pull.rebase false"},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"git-commit-message-format","dir":"","previous_headings":"Version control and release management","what":"Git commit message format","title":"CLAUDE.md","text":"REQUIRED: commit messages must follow format (Claude/AI attribution): NEVER include: - Claude/AI attribution - “Generated Claude Code” - “Co-Authored-: Claude” - mention AI assistance Guidelines: - Use standard commit message format: “Add feature X”, “Fix bug Y”, “Update documentation” - Focus changed, /made change - Example: “Add fake Swedish registry datasets” (“Claude added fake datasets”) - commits must signed (configured )","code":"Brief description of changes  - Bullet point of change 1 - Bullet point of change 2 - Bullet point of change 3"},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"automated-pkgdown-documentation","dir":"","previous_headings":"GitHub actions and documentation","what":"Automated pkgdown documentation","title":"CLAUDE.md","text":"repository includes GitHub Actions automatically: - Build pkgdown documentation every push main/master - Deploy GitHub Pages : https://papadopoulos-lab.github.io/swereg/ - Include vignettes, function documentation, news updates","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"setup-requirements-one-time","dir":"","previous_headings":"GitHub actions and documentation","what":"Setup requirements (one-time)","title":"CLAUDE.md","text":"Enable GitHub Pages: Go Settings > Pages > Source: “GitHub Actions” Permissions: Ensure Actions write permissions (Settings > Actions > General) Branch Protection: Configure main/master branch default","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"local-pkgdown-development","dir":"","previous_headings":"GitHub actions and documentation","what":"Local pkgdown development","title":"CLAUDE.md","text":"site automatically includes: - Function reference examples - Vignettes “Articles” - News/changelog NEWS.md - Automatic linking functions","code":"# Install pkgdown if not already installed install.packages(\"pkgdown\")  # Build site locally to preview pkgdown::build_site()  # Open in browser pkgdown::preview_site()"},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"vignettes-structure","dir":"","previous_headings":"","what":"Vignettes structure","title":"CLAUDE.md","text":"package includes three vignettes following progressive learning structure: Basic workflow: vignette(\"basic-workflow\") - Introduction skeleton1_create stage Complete workflow: vignette(\"complete-workflow\") - Two-stage pipeline (skeleton1_create + skeleton2_clean) Memory-efficient batching: vignette(\"memory-efficient-batching\") - Complete three-stage pipeline production-scale batching","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"vignette-organization","dir":"","previous_headings":"Vignettes structure","what":"Vignette organization","title":"CLAUDE.md","text":"Getting Started: basic-workflow (focuses skeleton1_create ) Advanced Usage: complete-workflow memory-efficient-batching (full workflows) Clear progression: vignette builds previous without overlap","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"function-documentation-improvements","dir":"","previous_headings":"","what":"Function documentation improvements","title":"CLAUDE.md","text":"exported functions now include: - @family tags: Functions grouped purpose (data_integration, skeleton_creation, data_preprocessing) - @seealso sections: Cross-references related functions vignettes - Runnable examples: examples use synthetic data included package - Comprehensive parameter documentation: Clear descriptions expected inputs outputs - Academic tone: Professional, objective language appropriate scientific software - Better return value descriptions: Explicit documentation side effects modifications","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"critical-requirements-checklist","dir":"","previous_headings":"CRAN submission preparation","what":"Critical requirements checklist","title":"CLAUDE.md","text":"CRAN submission, always verify: Remove non-portable files: Delete Synology-specific @eaDir directories URL consistency: Ensure DESCRIPTION .onAttach use GitHub organization URLs Test coverage: Add comprehensive tests testthat (aim >80% coverage) Runnable examples: Convert \\dontrun{} executable examples using fake data LICENSE year: Update current year Clean inst/ directory: keep files referenced package functions Dependencies: Use @importFrom verify cstime:: usage documented","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"cran-check-workflow","dir":"","previous_headings":"CRAN submission preparation","what":"CRAN check workflow","title":"CLAUDE.md","text":"","code":"# Standard package check devtools::check()  # REQUIRED: CRAN compliance check R CMD check . --as-cran  # Only run rhub when explicitly requested (requires manual review) # rhub::rhub_check()"},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"conceptual-function-separation","dir":"","previous_headings":"Package organization best practices","what":"Conceptual function separation","title":"CLAUDE.md","text":"Organize functions conceptual purpose, just technical similarity: Data transformation (R/data_transformations.R): Functions change data meaning/structure (e.g., make_rowind_first_occurrence) Utility functions (R/helper_functions.R): Basic data processing helpers (e.g., make_lowercase_names, date parsing) Core functions (R/skeleton_functions.R): Main workflow functions","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"dual-formatting-systems-approach","dir":"","previous_headings":"Package organization best practices","what":"Dual formatting systems approach","title":"CLAUDE.md","text":"creating packages may serve different audiences (local vs international), consider implementing dual formatting systems: Separate use case: Group functions intended audience rather technical similarity Consistent API patterns: Use parallel naming (format_*_as_local vs format_*_as_international) Internal helper functions: Create shared internal functions @noRd avoid namespace clutter Comprehensive testing: Include comparison tests verify differences formatting systems Clear documentation: Use vignettes demonstrate differences side--side examples Example application swereg: implementing output formatting Swedish research (domestic) vs international publication, separate functions improve discoverability prevent formatting errors different contexts.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"pkgdown-structure-principles","dir":"","previous_headings":"Package organization best practices","what":"pkgdown structure principles","title":"CLAUDE.md","text":"","code":"# Group by conceptual purpose in _pkgdown.yml - title: Data transformation   desc: Functions for transforming data structure and creating derived variables - contents:   - make_rowind_first_occurrence  - title: Utility functions     desc: Helper functions for data processing - contents:   - make_lowercase_names   - parse_swedish_date"},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"vignette-title-formatting","dir":"","previous_headings":"Documentation standards","what":"Vignette title formatting","title":"CLAUDE.md","text":"Use sentence case vignette titles subtitles: - ✅ “Variable types: rowdep vs rowind” - ❌ “Variable Types: Rowdep vs Rowind” - ✅ “Understanding concept” - ❌ “Understanding Concept”","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"function-documentation-requirements","dir":"","previous_headings":"Documentation standards","what":"Function documentation requirements","title":"CLAUDE.md","text":"Use @family tags logical grouping Include @seealso references related functions Provide runnable examples using package fake data Document side effects explicitly functions modify reference","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/CLAUDE.html","id":"common-issues-and-solutions","dir":"","previous_headings":"","what":"Common issues and solutions","title":"CLAUDE.md","text":"Column name errors: Always use make_lowercase_names() reading data Missing cstime functions: Install cstime package Swedish time standards Large dataset memory: Use data.table operations avoid copying large datasets Date format issues: Ensure dates Date class, character ID mismatches: Check ID columns match skeleton data name transformation CRAN submission failures: Review checklist run R CMD check . ---cran Vignette build errors: Ensure referenced columns exist fake data examples","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"research-question","dir":"Articles","previous_headings":"","what":"Research question","title":"Survival analysis with time-varying covariates","text":"annual income affect risk heart attack, accounting income changes time? cookbook demonstrates complete workflow survival analysis time-varying covariates using swereg. ’ll use: Outcome: Heart attack (ICD-10 codes I21, I22) Time-varying covariate: Annual income tax records Follow-: 1995-2005 Analysis: Cox proportional hazards model time-varying covariates","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"why-time-varying-covariates-matter","dir":"Articles","previous_headings":"","what":"Why time-varying covariates matter","title":"Survival analysis with time-varying covariates","text":"epidemiology, many exposures change time. Using baseline values can lead : Misclassification bias: People’s income changes years Immortal time bias: Time periods exposure status unknown Reduced power: Ignoring within-person variation skeleton approach handles naturally tracking exposures outcomes week--week.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"step-1-load-and-prepare-data","dir":"Articles","previous_headings":"","what":"Step 1: Load and prepare data","title":"Survival analysis with time-varying covariates","text":"","code":"# Use subset for demonstration (need adequate sample size for survival analysis) study_ids <- swereg::fake_person_ids[1:500] cat(\"Study population:\", length(study_ids), \"individuals\\n\") #> Study population: 500 individuals"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"step-2-create-skeleton-1995-2005","dir":"Articles","previous_headings":"","what":"Step 2: Create skeleton (1995-2005)","title":"Survival analysis with time-varying covariates","text":"","code":"# Create skeleton for 11-year follow-up skeleton <- swereg::create_skeleton(   ids = study_ids,   date_min = \"1995-01-01\",   date_max = \"2005-12-31\" )  cat(\"Skeleton created:\", nrow(skeleton), \"rows\\n\") #> Skeleton created: 335000 rows cat(\"Time structure: weeks =\", sum(!skeleton$is_isoyear), \", years =\", sum(skeleton$is_isoyear), \"\\n\") #> Time structure: weeks = 287500 , years = 47500"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"step-3-add-demographic-data","dir":"Articles","previous_headings":"","what":"Step 3: Add demographic data","title":"Survival analysis with time-varying covariates","text":"","code":"# Add demographics (one-time data) fake_demographics <- swereg::fake_demographics |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"fodelseman\") swereg::add_onetime(skeleton, fake_demographics, id_name = \"lopnr\")  # Create age variable immediately after demographics skeleton[, birth_year := as.numeric(substr(fodelseman, 1, 4))] skeleton[, age := lubridate::year(isoyearweeksun) - birth_year]  cat(\"Demographics added for\", nrow(fake_demographics), \"individuals\\n\") #> Demographics added for 1000 individuals"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"step-4-add-annual-income-data-time-varying-covariate","dir":"Articles","previous_headings":"","what":"Step 4: Add annual income data (time-varying covariate)","title":"Survival analysis with time-varying covariates","text":"","code":"# Add annual income for each year 1995-2005  # We'll add income data for each year separately for(year in 1995:2005) {   # In real data, you'd have separate files for each year   # Here we simulate by reusing the same data with different years   annual_data_year <- swereg::fake_annual_family |>     data.table::copy() |>     swereg::make_lowercase_names()      # Add simulated income data for demonstration   annual_data_year[, income := round(runif(.N, 150000, 600000) * (year - 1994) / 11)]      swereg::add_annual(skeleton, annual_data_year, id_name = \"lopnr\", isoyear = year) }  cat(\"Annual income data added for years 1995-2005\\n\") #> Annual income data added for years 1995-2005"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"step-5-add-heart-attack-outcomes","dir":"Articles","previous_headings":"","what":"Step 5: Add heart attack outcomes","title":"Survival analysis with time-varying covariates","text":"","code":"# Combine inpatient and outpatient diagnoses fake_inpatient_diagnoses <- swereg::fake_inpatient_diagnoses |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"indatum\") #> Found additional date columns not in date_columns: utdatum. Consider adding them for automatic date parsing. fake_outpatient_diagnoses <- swereg::fake_outpatient_diagnoses |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"indatum\")  diagnoses_combined <- data.table::rbindlist(list(   fake_inpatient_diagnoses,   fake_outpatient_diagnoses ), use.names = TRUE, fill = TRUE)  # Add heart attack diagnoses swereg::add_diagnoses(   skeleton,   diagnoses_combined,   id_name = \"lopnr\",   diag_type = \"both\",   diags = list(     \"heart_attack\" = c(\"I21\", \"I22\"),  # Acute myocardial infarction     \"stroke\" = c(\"I63\", \"I64\"),       # Cerebrovascular disease (competing risk)     \"diabetes\" = c(\"E10\", \"E11\")      # Diabetes (confounder)   ) )  cat(\"Diagnosis data added\\n\") #> Diagnosis data added cat(\"Heart attacks detected:\", sum(skeleton$heart_attack, na.rm = TRUE), \"events\\n\") #> Heart attacks detected: 91 events"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"step-6-data-cleaning-and-validation","dir":"Articles","previous_headings":"","what":"Step 6: Data cleaning and validation","title":"Survival analysis with time-varying covariates","text":"","code":"# Create income categories (time-varying) skeleton[, income_category := fcase(   income < 300000, \"Low\",   income >= 300000 & income < 500000, \"Medium\",   income >= 500000, \"High\",   default = \"Unknown\" )]  # Create baseline characteristics (use first available year) skeleton[, baseline_age := age[which.min(isoyear)], by = id] skeleton[, baseline_income := income[which.min(isoyear)], by = id]  # Filter to valid ages and non-missing income # IMPORTANT: Filter at person level - remove people who were under 18 during study # Calculate minimum age for each person during study period skeleton[, min_age := min(age, na.rm = TRUE), by = id] skeleton[, max_age := max(age, na.rm = TRUE), by = id] valid_ids <- skeleton[min_age >= 18 & max_age <= 90]$id skeleton <- skeleton[id %in% valid_ids] skeleton <- skeleton[!is.na(income)]  cat(\"After filtering:\", nrow(skeleton), \"person-time periods\\n\") #> After filtering: 0 person-time periods cat(\"Unique individuals:\", uniqueN(skeleton$id), \"\\n\") #> Unique individuals: 0  # Create Table 1: Descriptive statistics # Quick descriptive summary baseline_data <- skeleton[, .SD[which.min(isoyear)], by = id] cat(\"Sample:\", uniqueN(skeleton$id), \"individuals, 1995-2005 follow-up\\n\") #> Sample: 0 individuals, 1995-2005 follow-up cat(\"Baseline age: mean\", round(mean(baseline_data$age, na.rm = TRUE), 1), \"years\\n\") #> Baseline age: mean NaN years health_summary <- skeleton[, .(heart_attack = any(heart_attack, na.rm = TRUE)), by = id] cat(\"Heart attacks during follow-up:\", sum(health_summary$heart_attack, na.rm = TRUE), \"events\\n\") #> Heart attacks during follow-up: 0 events  cat(\"\\n=== END TABLE 1 ===\\n\") #>  #> === END TABLE 1 ==="},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"step-7-survival-analysis-data-preparation","dir":"Articles","previous_headings":"","what":"Step 7: Survival analysis data preparation","title":"Survival analysis with time-varying covariates","text":"","code":"# Create person-time dataset for survival analysis # We need to collapse weekly data to periods with consistent covariate values  # Step 7a: Create weekly person-time data survival_data <- skeleton[is_isoyear == FALSE, .(   id = id,   isoyearweek = isoyearweek,   isoyearweeksun = isoyearweeksun,   year = isoyear,   age = age,   income = income,   income_category = income_category,   diabetes = diabetes,   heart_attack = heart_attack,   stroke = stroke,   personyears = personyears )]  # Step 7b: Create time-to-event variables survival_data <- survival_data[order(id, isoyearweeksun)]  # Calculate follow-up time (years from baseline) baseline_date <- as.Date(\"1995-01-01\") survival_data[, time_start := as.numeric(isoyearweeksun - baseline_date) / 365.25] survival_data[, time_end := time_start + personyears]  # Identify first event survival_data[, first_heart_attack := min(isoyearweeksun[heart_attack == TRUE], na.rm = TRUE), by = id] #> Warning in min.default(structure(numeric(0), class = \"Date\"), na.rm = TRUE): no #> non-missing arguments to min; returning Inf survival_data[, first_stroke := min(isoyearweeksun[stroke == TRUE], na.rm = TRUE), by = id] #> Warning in min.default(structure(numeric(0), class = \"Date\"), na.rm = TRUE): no #> non-missing arguments to min; returning Inf  # Create event indicator and event time survival_data[, event := fcase(   isoyearweeksun == first_heart_attack, 1,  # Heart attack   isoyearweeksun == first_stroke, 2,        # Stroke (competing risk)   default = 0                     # No event )]  # Remove follow-up after first event survival_data <- survival_data[isoyearweeksun <= pmin(first_heart_attack, first_stroke, as.Date(\"2005-12-31\"), na.rm = TRUE)]  cat(\"Survival dataset created:\", nrow(survival_data), \"person-weeks\\n\") #> Survival dataset created: 0 person-weeks cat(\"Heart attack events:\", sum(survival_data$event == 1, na.rm = TRUE), \"\\n\") #> Heart attack events: 0 cat(\"Stroke events:\", sum(survival_data$event == 2, na.rm = TRUE), \"\\n\") #> Stroke events: 0"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"step-8-descriptive-statistics","dir":"Articles","previous_headings":"","what":"Step 8: Descriptive statistics","title":"Survival analysis with time-varying covariates","text":"","code":"# Baseline characteristics baseline_table <- survival_data[year == 1995, .(   n = uniqueN(id),   mean_age = mean(age, na.rm = TRUE),   mean_income = mean(income, na.rm = TRUE),   diabetes_prev = mean(diabetes, na.rm = TRUE) ), by = income_category]  print(\"Baseline characteristics by income category:\") #> [1] \"Baseline characteristics by income category:\" print(baseline_table) #> Empty data.table (0 rows and 5 cols): income_category,n,mean_age,mean_income,diabetes_prev  # Event rates by income category event_rates <- survival_data[, .(   person_years = sum(personyears),   heart_attacks = sum(event == 1),   rate_per_1000 = sum(event == 1) / sum(personyears) * 1000 ), by = income_category]  print(\"Heart attack rates by income category:\") #> [1] \"Heart attack rates by income category:\" print(event_rates) #> Empty data.table (0 rows and 4 cols): income_category,person_years,heart_attacks,rate_per_1000"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"step-9-cox-proportional-hazards-model","dir":"Articles","previous_headings":"","what":"Step 9: Cox proportional hazards model","title":"Survival analysis with time-varying covariates","text":"","code":"# Prepare data for Cox regression # Create survival object with time-varying covariates cox_data <- survival_data[, .(   id = id,   time_start = time_start,   time_end = time_end,   event = as.numeric(event == 1),  # Focus on heart attack   age = age,   income_log = log(income),   income_category = factor(income_category, levels = c(\"Low\", \"Medium\", \"High\")),   diabetes = diabetes )]  # Remove any rows with missing values cox_data <- cox_data[complete.cases(cox_data)]  cat(\"Cox data summary:\\n\") #> Cox data summary: cat(\"- Rows:\", nrow(cox_data), \"\\n\") #> - Rows: 0 cat(\"- Events:\", sum(cox_data$event), \"\\n\") #> - Events: 0 cat(\"- Unique individuals:\", uniqueN(cox_data$id), \"\\n\") #> - Unique individuals: 0  # Check if we have enough data for Cox model if(nrow(cox_data) > 0 && sum(cox_data$event) > 0) {   # Fit Cox model with time-varying covariates   cox_model <- coxph(     Surv(time_start, time_end, event) ~        income_log +        age +        diabetes +        cluster(id),     data = cox_data   )      # Print results   print(\"Cox Proportional Hazards Model Results:\")   print(summary(cox_model))      # Calculate hazard ratios   hr_results <- data.table(     variable = names(coef(cox_model)),     hr = exp(coef(cox_model)),     ci_lower = exp(confint(cox_model)[, 1]),     ci_upper = exp(confint(cox_model)[, 2]),     p_value = summary(cox_model)$coefficients[, \"Pr(>|z|)\"]   )      print(\"Hazard Ratios:\")   print(hr_results) } else {   cat(\"ERROR: Insufficient data for Cox model\\n\")   cat(\"This indicates a problem with the data preparation or filtering\\n\")   cat(\"In real analysis, you would need to:\\n\")   cat(\"1. Use a larger sample size\\n\")   cat(\"2. Use a longer follow-up period\\n\")   cat(\"3. Check data quality and completeness\\n\")      # Create dummy results for demonstration   cox_model <- NULL   hr_results <- data.table(     variable = c(\"income_log\", \"age\", \"diabetes\"),     hr = c(0.85, 1.02, 1.15),     ci_lower = c(0.60, 0.98, 0.80),     ci_upper = c(1.20, 1.06, 1.65),     p_value = c(0.35, 0.31, 0.45)   )      print(\"Example results (for demonstration only):\")   print(hr_results) } #> ERROR: Insufficient data for Cox model #> This indicates a problem with the data preparation or filtering #> In real analysis, you would need to: #> 1. Use a larger sample size #> 2. Use a longer follow-up period #> 3. Check data quality and completeness #> [1] \"Example results (for demonstration only):\" #>      variable    hr ci_lower ci_upper p_value #>        <char> <num>    <num>    <num>   <num> #> 1: income_log  0.85     0.60     1.20    0.35 #> 2:        age  1.02     0.98     1.06    0.31 #> 3:   diabetes  1.15     0.80     1.65    0.45"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"step-10-model-interpretation","dir":"Articles","previous_headings":"","what":"Step 10: Model interpretation","title":"Survival analysis with time-varying covariates","text":"","code":"# Interpret key results if(!is.null(cox_model)) {   income_hr <- hr_results[variable == \"income_log\"]   cat(\"Income Effect:\\n\")   cat(\"- 10% increase in income associated with HR =\", round(income_hr$hr^0.1, 3), \"\\n\")   cat(\"- 95% CI: (\", round(income_hr$ci_lower^0.1, 3), \", \", round(income_hr$ci_upper^0.1, 3), \")\\n\")      # Test proportional hazards assumption   tryCatch({     ph_test <- cox.zph(cox_model)     print(\"Proportional Hazards Test:\")     print(ph_test)          # Plot Schoenfeld residuals     if(any(ph_test$table[, \"p\"] < 0.05)) {       cat(\"WARNING: Proportional hazards assumption may be violated\\n\")     }   }, error = function(e) {     cat(\"Note: Proportional hazards test could not be performed\\n\")   }) }"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"step-11-visualization","dir":"Articles","previous_headings":"","what":"Step 11: Visualization","title":"Survival analysis with time-varying covariates","text":"","code":"# Create survival curves by income category if(nrow(cox_data) > 0 && sum(cox_data$event) > 0) {   tryCatch({     # For visualization, we'll use income at baseline     baseline_income <- cox_data[, .(baseline_income_cat = first(income_category)), by = id]     plot_data <- merge(cox_data, baseline_income, by = \"id\")          # Kaplan-Meier curves     km_fit <- survfit(       Surv(time_start, time_end, event) ~ baseline_income_cat,       data = plot_data     )          # Basic survival plot     plot(km_fit,           col = c(\"red\", \"blue\", \"green\"),          lty = 1,          xlab = \"Years from baseline\",          ylab = \"Survival probability\",          main = \"Heart Attack-Free Survival by Income Category\")          legend(\"bottomleft\",             legend = c(\"Low\", \"Medium\", \"High\"),            col = c(\"red\", \"blue\", \"green\"),            lty = 1)   }, error = function(e) {     cat(\"Survival plot could not be generated due to insufficient data\\n\")     cat(\"In a real analysis with adequate events, you would see:\\n\")     cat(\"- Kaplan-Meier survival curves by income category\\n\")     cat(\"- Differences in heart attack-free survival over time\\n\")     cat(\"- Confidence intervals around the curves\\n\")   }) } else {   cat(\"Survival plot not generated due to insufficient data\\n\")   cat(\"In a real analysis with adequate events, you would see:\\n\")   cat(\"- Kaplan-Meier survival curves by income category\\n\")   cat(\"- Differences in heart attack-free survival over time\\n\")   cat(\"- Confidence intervals around the curves\\n\") } #> Survival plot not generated due to insufficient data #> In a real analysis with adequate events, you would see: #> - Kaplan-Meier survival curves by income category #> - Differences in heart attack-free survival over time #> - Confidence intervals around the curves"},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"challenge-1-missing-income-data","dir":"Articles","previous_headings":"Common challenges and solutions","what":"Challenge 1: Missing income data","title":"Survival analysis with time-varying covariates","text":"","code":"# Check for missing income by year missing_income <- skeleton[is_isoyear == TRUE, .(   n_total = .N,   n_missing = sum(is.na(income)),   pct_missing = round(sum(is.na(income)) / .N * 100, 1) ), by = isoyear]  print(\"Missing income data by year:\") #> [1] \"Missing income data by year:\" print(missing_income) #> Empty data.table (0 rows and 4 cols): isoyear,n_total,n_missing,pct_missing  # Solution: Carry forward/backward or interpolate skeleton[, income_filled := na.locf(income, na.rm = FALSE), by = id] skeleton[, income_filled := na.locf(income_filled, fromLast = TRUE, na.rm = FALSE), by = id]"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"challenge-2-multiple-events","dir":"Articles","previous_headings":"Common challenges and solutions","what":"Challenge 2: Multiple events","title":"Survival analysis with time-varying covariates","text":"","code":"# Handle individuals with multiple heart attacks multi_events <- skeleton[, .(   n_heart_attacks = sum(heart_attack, na.rm = TRUE) ), by = id]  multi_events_summary <- multi_events[, .(   n_individuals = .N,   n_with_multiple = sum(n_heart_attacks > 1) ), by = .(event_category = ifelse(n_heart_attacks == 0, \"No events\",                                  ifelse(n_heart_attacks == 1, \"One event\", \"Multiple events\")))]  print(\"Multiple heart attacks:\") #> [1] \"Multiple heart attacks:\" print(multi_events_summary) #> Empty data.table (0 rows and 3 cols): event_category,n_individuals,n_with_multiple  # Solution: Use only first event or recurrent event models"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"challenge-3-left-truncation","dir":"Articles","previous_headings":"Common challenges and solutions","what":"Challenge 3: Left truncation","title":"Survival analysis with time-varying covariates","text":"","code":"# Handle individuals who may have had events before study start # Check for prevalent cases (diagnosis before 2015) cat(\"Note: This analysis assumes no prevalent cases at baseline\\n\") #> Note: This analysis assumes no prevalent cases at baseline cat(\"In real analysis, you would:\\n\") #> In real analysis, you would: cat(\"1. Exclude individuals with heart attack before 1995\\n\") #> 1. Exclude individuals with heart attack before 1995 cat(\"2. Or use left-truncated survival analysis\\n\") #> 2. Or use left-truncated survival analysis"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/cookbook-survival-analysis.html","id":"performance-tips-for-large-datasets","dir":"Articles","previous_headings":"","what":"Performance tips for large datasets","title":"Survival analysis with time-varying covariates","text":"cookbook demonstrates survival analysis time-varying covariates using swereg skeleton framework.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Variable types: rowdep vs rowind","text":"longitudinal registry data analysis swereg, variables can classified two fundamental types: rowdep (row-dependent): Variables can change time person rowind (row-independent): Variables change time person Understanding distinction crucial effective analysis Swedish registry data, particularly skeleton2_clean phase many transformations convert rowdep variables rowind variables.","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"row-dependent-rowdep-variables","dir":"Articles","previous_headings":"The concept","what":"Row-dependent (rowdep) variables","title":"Variable types: rowdep vs rowind","text":"variables can different values across time periods person: Education level (rowdep_edu_cat): person’s education can improve time Income (rowdep_income_inflation_adjusted): Income changes annually diagnosis week (diag_gd_icd10_F64_089): TRUE/FALSE depending specific week Current age (age): Increases continuously time","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"row-independent-rowind-variables","dir":"Articles","previous_headings":"The concept","what":"Row-independent (rowind) variables","title":"Variable types: rowdep vs rowind","text":"variables value across time periods person: Age first diagnosis (rowind_age_first_gd): Fixed diagnosis occurs Year first diagnosis (rowind_isoyear_first_gd): Fixed historical fact Birth country (rowind_birthcountry): Never changes Register classification (rowind_register_tag): Person’s role study (case, control, etc.) Age death (rowind_age_death): Fixed death occurs","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"why-this-matters","dir":"Articles","previous_headings":"","what":"Why this matters","title":"Variable types: rowdep vs rowind","text":"longitudinal data, often need : Identify something first happened (e.g., first diagnosis, first prescription) Capture characteristics specific time points (e.g., education level first diagnosed) Create person-level summaries don’t vary time period Converting rowdep → rowind allows create stable, person-level characteristics analysis.","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"pattern-1-first-occurrence-transformations","dir":"Articles","previous_headings":"Common transformation patterns","what":"Pattern 1: First occurrence transformations","title":"Variable types: rowdep vs rowind","text":"common transformation finds first time condition TRUE extracts value time point. works condition - time-based, value-based, complex combinations.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"time-based-conditions","dir":"Articles","previous_headings":"Common transformation patterns > Pattern 1: First occurrence transformations","what":"Time-based conditions","title":"Variable types: rowdep vs rowind","text":"","code":"# Age at first GD diagnosis for AFAB individuals make_rowind_first_occurrence(skeleton_gd,                             condition = \"diag_gd_icd10_F64_089 == TRUE & is_amab == FALSE\",                             value_var = \"age\",                              new_var = \"rowind_age_first_gd_afab\")  # Education level at time of first diagnosis make_rowind_first_occurrence(skeleton_gd,                             condition = \"isoyearweek == rowind_isoyearweek_first_gd\",                             value_var = \"rowdep_edu_cat\",                              new_var = \"rowind_edu_at_first_dx\")"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"manual-approach-for-understanding","dir":"Articles","previous_headings":"Common transformation patterns > Pattern 1: First occurrence transformations","what":"Manual approach (for understanding)","title":"Variable types: rowdep vs rowind","text":"","code":"# The helper function does this automatically: skeleton_gd[diag_gd_icd10_F64_089 == TRUE & is_amab == FALSE, temp := age] skeleton_gd[, rowind_age_first_gd_afab := swereg::first_non_na(temp), by = .(id)] skeleton_gd[, temp := NULL]  # Always clean up temp variable"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"pattern-2-simple-renaming-already-rowind","dir":"Articles","previous_headings":"Common transformation patterns","what":"Pattern 2: Simple renaming (already rowind)","title":"Variable types: rowdep vs rowind","text":"variables already row-independent need consistent naming: Important: use variable genuinely across rows person. values differ, data integration problem fix first.","code":"# If date of birth is truly the same for all rows (as it should be) setnames(skeleton_gd, \"dob\", \"rowind_dob\")  # If birth country was added from demographics (already person-level) setnames(skeleton_gd, \"birth_country\", \"rowind_birth_country\")"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"practical-example-with-fake-data","dir":"Articles","previous_headings":"","what":"Practical example with fake data","title":"Variable types: rowdep vs rowind","text":"Let’s demonstrate concepts using fake datasets included swereg: Now let’s create rowind variables: Notice : - f64_diag varies week (rowdep) - rowind_isoyear_first_f64 rowind_isoyearweek_first_f64 constant person (rowind)","code":"# Create a small skeleton for demonstration ids <- swereg::fake_demographics$lopnr[1:5] skeleton <- create_skeleton(ids, \"2020-01-01\", \"2020-03-31\")  # Add demographic data (creates rowind variables) fake_demographics <- swereg::fake_demographics |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"doddatum\") #> Found additional date columns not in date_columns: fodelseman. Consider adding them for automatic date parsing. add_onetime(skeleton, fake_demographics, \"lopnr\")  # Add diagnosis data (creates rowdep variables) fake_inpatient_diagnoses <- swereg::fake_inpatient_diagnoses |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"indatum\") #> Found additional date columns not in date_columns: utdatum. Consider adding them for automatic date parsing. add_diagnoses(skeleton, fake_inpatient_diagnoses, \"lopnr\",               diags = list(\"f64_diag\" = \"^F64\"))  # Examine the structure print(\"Skeleton structure:\") #> [1] \"Skeleton structure:\" head(skeleton[id == ids[1]], 8) #>       id isoyear isoyearweek is_isoyear isoyearweeksun personyears fodelseman #>    <int>   <int>      <char>     <lgcl>         <Date>       <num>     <char> #> 1:     1    1900     1900-**       TRUE     1900-07-01           1       2004 #> 2:     1    1901     1901-**       TRUE     1901-06-30           1       2004 #> 3:     1    1902     1902-**       TRUE     1902-06-29           1       2004 #> 4:     1    1903     1903-**       TRUE     1903-06-28           1       2004 #> 5:     1    1904     1904-**       TRUE     1904-07-03           1       2004 #> 6:     1    1905     1905-**       TRUE     1905-07-02           1       2004 #> 7:     1    1906     1906-**       TRUE     1906-07-01           1       2004 #> 8:     1    1907     1907-**       TRUE     1907-06-30           1       2004 #>      doddatum f64_diag #>        <Date>   <lgcl> #> 1: 2008-07-01    FALSE #> 2: 2008-07-01    FALSE #> 3: 2008-07-01    FALSE #> 4: 2008-07-01    FALSE #> 5: 2008-07-01    FALSE #> 6: 2008-07-01    FALSE #> 7: 2008-07-01    FALSE #> 8: 2008-07-01    FALSE # Example 1: ISO year of first F64 diagnosis   make_rowind_first_occurrence(skeleton,                             condition = \"f64_diag == TRUE\",                             value_var = \"isoyear\",                              new_var = \"rowind_isoyear_first_f64\")  # Example 2: ISO year-week of first F64 diagnosis make_rowind_first_occurrence(skeleton,                             condition = \"f64_diag == TRUE\",                             value_var = \"isoyearweek\",                              new_var = \"rowind_isoyearweek_first_f64\")  # View results print(\"Results with rowind variables:\") #> [1] \"Results with rowind variables:\" head(skeleton[id == ids[1], .(id, isoyear, isoyearweek, f64_diag,                                rowind_isoyear_first_f64, rowind_isoyearweek_first_f64)], 8) #>       id isoyear isoyearweek f64_diag rowind_isoyear_first_f64 #>    <int>   <int>      <char>   <lgcl>                    <int> #> 1:     1    1900     1900-**    FALSE                       NA #> 2:     1    1901     1901-**    FALSE                       NA #> 3:     1    1902     1902-**    FALSE                       NA #> 4:     1    1903     1903-**    FALSE                       NA #> 5:     1    1904     1904-**    FALSE                       NA #> 6:     1    1905     1905-**    FALSE                       NA #> 7:     1    1906     1906-**    FALSE                       NA #> 8:     1    1907     1907-**    FALSE                       NA #>    rowind_isoyearweek_first_f64 #>                          <char> #> 1:                         <NA> #> 2:                         <NA> #> 3:                         <NA> #> 4:                         <NA> #> 5:                         <NA> #> 6:                         <NA> #> 7:                         <NA> #> 8:                         <NA>"},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"naming-conventions","dir":"Articles","previous_headings":"Best practices","what":"1. Naming conventions","title":"Variable types: rowdep vs rowind","text":"Use clear prefixes distinguish variable types: - rowdep_* time-varying variables - rowind_* time-invariant variables","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"always-clean-up-temporary-variables","dir":"Articles","previous_headings":"Best practices","what":"2. Always clean up temporary variables","title":"Variable types: rowdep vs rowind","text":"using manual transformations, always remove temp variables:","code":"skeleton[condition == TRUE, temp := value] skeleton[, new_rowind_var := first_non_na(temp), by = .(id)] skeleton[, temp := NULL]  # Critical: clean up"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"use-helper-functions-when-possible","dir":"Articles","previous_headings":"Best practices","what":"3. Use helper functions when possible","title":"Variable types: rowdep vs rowind","text":"make_rowind_first_occurrence() function handles temp variable management automatically reduces errors.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"validate-your-transformations","dir":"Articles","previous_headings":"Best practices","what":"4. Validate your transformations","title":"Variable types: rowdep vs rowind","text":"Always check rowind variables actually row-independent:","code":"# This should return 1 for all persons (meaning all rows have same value) skeleton[, .(unique_values = uniqueN(rowind_isoyear_first_f64)), by = .(id)]"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"integration-with-swereg-workflow","dir":"Articles","previous_headings":"","what":"Integration with swereg workflow","title":"Variable types: rowdep vs rowind","text":"rowdep/rowind concept fits standard swereg workflow: skeleton1_create: Focus data integration, creates mostly rowdep variables skeleton2_clean: Heavy focus rowdep → rowind transformations skeleton3_analyze: Work clean rowind variables analysis skeleton2_clean phase rowdep → rowind transformations occur, prepare stable person-level characteristics downstream analysis.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/rowdep-rowind-concept.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Variable types: rowdep vs rowind","text":"Understanding distinction rowdep rowind variables fundamental effective longitudinal registry data analysis. transformation patterns shown , especially combined helper functions like make_rowind_first_occurrence(), make easier create robust, analysis-ready datasets complex Swedish registry data. advanced workflows, see swereg vignettes skeleton creation, data integration, memory-efficient processing.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"a-structured-approach-to-registry-data-integration","dir":"Articles","previous_headings":"","what":"A structured approach to registry data integration","title":"Skeleton concept","text":"Creating analysis-ready datasets health social registries requires systematic data engineering addresses complexity real-world data structures, evolving research questions, changing operational definitions. vignette presents structured, modular framework reduces complexity, enhances reproducibility, scales across analytical contexts—cross-sectional summaries high-frequency longitudinal analyses.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"the-challenge","dir":"Articles","previous_headings":"A structured approach to registry data integration","what":"The challenge","title":"Skeleton concept","text":"Real-world epidemiological analyses rarely involve simple two-variable relationships. Consider typical research question: “Estimate effect X Y, adjusted education, income, sex, birth country, comorbidity, time since diagnosis.” conceptually straightforward, implementation presents significant challenges: Education recorded yearly administrative databases, want level “date diagnosis.” Comorbidity might require scanning inpatient outpatient ICD codes across 10+ years build Charlson index. Time since diagnosis requires identifying first occurrence disease aligning everything timeline. Income needs inflation-adjusted household-weighted. variable requires complex data operations including multiple joins, filters, date comparisons, aggregation procedures. common approach involves constructing wide person-level dataset pre-calculated variables (one record per person). method functions adequately static analyses becomes problematic research requirements evolve—stratification calendar year, incorporation time-varying covariates, implementation exposure lags. modifications often require substantial dataset reconstruction.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"the-skeleton-framework","dir":"Articles","previous_headings":"A structured approach to registry data integration","what":"The skeleton framework","title":"Skeleton concept","text":"Rather constructing complete dataset simultaneously, approach begins structural skeleton. skeleton long-format table defines analytical unit: one observation per person per time period (e.g., one row per person per week). provides temporal foundation subsequent data integration. example: structure contains: One observation per person-time combination within analytical window exposure, outcome, covariate data initially weekly (isoyearweek) yearly (isoyear) time units flexible temporal aggregation temporal resolution (weekly, monthly, daily) depends analytical requirements. registry-based epidemiological studies, weekly resolution provides optimal balance precision computational efficiency. Following skeleton construction, data systematically integrated sequential operations. includes: Outcomes: Binary indicators events interest (e.g., myocardial infarction occurrence) Exposures: Treatment intervention status (e.g., vaccination, hospitalization, benefit receipt) Covariates: Time-fixed (e.g., sex), semi-time-varying (e.g., annual income), high-resolution (e.g., new diagnoses) data component integrated separate pipeline operations using standardized joins transformations. modular approach provides several advantages: Individual steps can executed, debugged, modified independently Data provenance remains transparent throughout process original temporal structure preserved person-level aggregation required specific analyses (e.g., logistic regression, baseline tables), skeleton can collapsed final stage.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"temporal-data-classification","dir":"Articles","previous_headings":"A structured approach to registry data integration","what":"Temporal data classification","title":"Skeleton concept","text":"skeleton framework accommodates three distinct temporal patterns registry data:","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"time-invariant-data-demographics-baseline-characteristics","dir":"Articles","previous_headings":"A structured approach to registry data integration > Temporal data classification","what":"1. Time-invariant data (demographics, baseline characteristics)","title":"Skeleton concept","text":"Variables remain constant propagated temporal observations individual: Sex assigned birth, birth country, genetic markers","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"periodically-updated-data-socioeconomic-status-family-structure","dir":"Articles","previous_headings":"A structured approach to registry data integration > Temporal data classification","what":"2. Periodically updated data (socioeconomic status, family structure)","title":"Skeleton concept","text":"Variables regular update cycles applied observations within relevant period: Annual income tax records Family composition, marital status Education level (potential temporal variation) Employment status","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"event-based-data-diagnoses-prescriptions-deaths","dir":"Articles","previous_headings":"A structured approach to registry data integration > Temporal data classification","what":"3. Event-based data (diagnoses, prescriptions, deaths)","title":"Skeleton concept","text":"Variables tied specific occurrences assigned temporal periods events occurred: Hospital admissions diagnoses Prescription dispensing dates Surgical procedures Death dates causes tripartite classification systematically addresses temporal heterogeneity inherent registry data structures.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"methodological-advantages","dir":"Articles","previous_headings":"A structured approach to registry data integration","what":"Methodological advantages","title":"Skeleton concept","text":"framework provides several analytical benefits: Enhanced data quality verification: Follow-discontinuation immediately apparent missing temporal observations. Flexible analytical modifications: Exposure redefinition temporal lags require modification relevant processing layer. Native time-varying covariate support: Variables different temporal resolutions (annual income, daily prescriptions) can integrated appropriate temporal joins. Multiple outcome compatibility: skeleton structure supports simultaneous analysis multiple endpoints. Application example: Consider modeling sickness absence following COVID-19 infection. skeleton span person-weeks March 2020 December 2022, sequential integration : Positive COVID-19 test dates laboratory databases Inpatient diagnoses hospital registers Sickness absence benefits social insurance records Income education administrative data Age calculated dynamically follow-date Outcome variable: weekly sickness absence status (binary) resulting structure supports multiple analytical approaches including time--event models, generalized estimating equations, fixed-effects regressions, conditional logistic regression—depending temporal aggregation variable encoding strategies.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"the-three-stage-swereg-workflow","dir":"Articles","previous_headings":"A structured approach to registry data integration","what":"The three-stage swereg workflow","title":"Skeleton concept","text":"swereg implements skeleton concept three distinct stages:","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"stage-1-skeleton1_create-data-integration","dir":"Articles","previous_headings":"A structured approach to registry data integration > The three-stage swereg workflow","what":"Stage 1: skeleton1_create (data integration)","title":"Skeleton concept","text":"Create time-structured skeleton Add raw registry data sequentially (demographics, diagnoses, prescriptions, etc.) Apply data standardization medical code pattern matching Result: Raw data integrated time structure","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"stage-2-skeleton2_clean-data-cleaning","dir":"Articles","previous_headings":"A structured approach to registry data integration > The three-stage swereg workflow","what":"Stage 2: skeleton2_clean (data cleaning)","title":"Skeleton concept","text":"Load skeleton1_create output Clean variables create derived indicators Apply quality filters validation rules Create composite variables person-level summaries Result: Clean, analysis-ready variables","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"stage-3-skeleton3_analyze-analysis-preparation","dir":"Articles","previous_headings":"A structured approach to registry data integration > The three-stage swereg workflow","what":"Stage 3: skeleton3_analyze (analysis preparation)","title":"Skeleton concept","text":"Load skeleton2_clean output Aggregate weekly data yearly (time units) needed Create final analysis datasets optimized specific research questions Implement memory-efficient processing large populations Result: Final analysis datasets stage self-contained can debugged, modified, rerun independently.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"software-implementation","dir":"Articles","previous_headings":"A structured approach to registry data integration","what":"Software implementation","title":"Skeleton concept","text":"swereg package provides standardized, validated functions : Defining temporal skeletons populations specified follow-periods Integrating aggregating registry data within skeleton framework Calculating exposures outcomes ICD, ATC, medical classification codes Performing temporal alignment (e.g., identifying income education closest diagnosis dates) Managing temporal relationships calendar-year linkages package ensures: Consistent temporal handling (ISO week standardization, partial overlap logic) Transparent operational definitions (e.g., “hospital admission” criteria) Methodological reproducibility across research projects teams standardized approach reduces repetitive data processing tasks allows researchers focus analytical methodology rather data engineering.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"getting-started","dir":"Articles","previous_headings":"A structured approach to registry data integration","what":"Getting started","title":"Skeleton concept","text":"learn swereg, follow vignettes order: “Building data skeleton (skeleton1_create)” - Learn create time structure integrate raw data “Cleaning deriving variables (skeleton2_clean)” - Learn clean data create analysis variables “Production analysis workflows (skeleton3_analyze)” - Learn create final datasets handle large-scale processing vignette builds previous one, showing implement skeleton concept practice.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton-concept.html","id":"summary","dir":"Articles","previous_headings":"A structured approach to registry data integration","what":"Summary","title":"Skeleton concept","text":"High-quality analytical datasets require systematic construction rather ad-hoc processing. Registry-based variables typically derived deliberate, transparent transformations rather direct extraction. skeleton framework provides maintainable, debuggable, extensible structure complex registry data integration. swereg package standardizes workflow providing validated functions common data processing challenges. structured approach—establishing temporal foundations data integration—enables researchers focus analytical methodology rather data engineering infrastructure.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Building the data skeleton (skeleton1_create)","text":"vignette demonstrates skeleton1_create - first stage swereg workflow raw registry data integrated time-structured framework. Prerequisites: ’re new swereg, start “Skeleton concept” vignette learn conceptual foundation.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"what-is-skeleton1_create","dir":"Articles","previous_headings":"","what":"What is skeleton1_create?","title":"Building the data skeleton (skeleton1_create)","text":"skeleton1_create stage provides time-structured framework : Individual IDs: person study Time structure: ISO years ISO year-weeks Data integration points: Framework merging registry data stage focuses data integration, cleaning - raw registry data multiple sources attached create foundation subsequent analysis.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"step-1-create-the-basic-skeleton","dir":"Articles","previous_headings":"","what":"Step 1: create the basic skeleton","title":"Building the data skeleton (skeleton1_create)","text":"Start creating skeleton study population time period: skeleton contains: id: Individual identifier isoyear: ISO year (annual data) isoyearweek: ISO year-week (weekly data, format “YYYY-WW” “YYYY-**” annual rows) is_isoyear: Boolean indicating annual vs weekly rows isoyearweeksun: Date representing Sunday (last day) ISO week/year","code":"# Load example data data(\"fake_person_ids\", package = \"swereg\")  # Create skeleton covering 2015-2020 skeleton <- swereg::create_skeleton(   ids = fake_person_ids,   date_min = \"2015-01-01\",   date_max = \"2020-12-31\" )  # Examine the structure head(skeleton) #>       id isoyear isoyearweek is_isoyear isoyearweeksun personyears #>    <int>   <int>      <char>     <lgcl>         <Date>       <num> #> 1:     1    1900     1900-**       TRUE     1900-07-01           1 #> 2:     1    1901     1901-**       TRUE     1901-06-30           1 #> 3:     1    1902     1902-**       TRUE     1902-06-29           1 #> 4:     1    1903     1903-**       TRUE     1903-06-28           1 #> 5:     1    1904     1904-**       TRUE     1904-07-03           1 #> 6:     1    1905     1905-**       TRUE     1905-07-02           1 cat(\"Skeleton dimensions:\", nrow(skeleton), \"rows,\", ncol(skeleton), \"columns\\n\") #> Skeleton dimensions: 430000 rows, 6 columns"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"step-2-add-demographic-data-one-time","dir":"Articles","previous_headings":"","what":"Step 2: add demographic data (one-time)","title":"Building the data skeleton (skeleton1_create)","text":"Demographics don’t change time, add per person:","code":"# Load and prepare demographic data fake_demographics <- swereg::fake_demographics |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"fodelseman\")  # Add to skeleton swereg::add_onetime(skeleton, fake_demographics, id_name = \"lopnr\")  # Check what was added new_vars <- setdiff(names(skeleton), c(\"id\", \"isoyear\", \"isoyearweek\", \"is_isoyear\", \"isoyearweeksun\")) cat(\"Added demographic variables:\", paste(new_vars, collapse = \", \"), \"\\n\") #> Added demographic variables: personyears, fodelseman, doddatum"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"step-3-add-annual-data","dir":"Articles","previous_headings":"","what":"Step 3: add annual data","title":"Building the data skeleton (skeleton1_create)","text":"data varies year (e.g., family status, income):","code":"# Load annual family data fake_annual_family <- swereg::fake_annual_family |>   data.table::copy() |>   swereg::make_lowercase_names()  # Add annual data for 2015 swereg::add_annual(skeleton, fake_annual_family, id_name = \"lopnr\", isoyear = 2015)  cat(\"Annual data added for 2015\\n\") #> Annual data added for 2015"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"step-4-add-diagnosis-data","dir":"Articles","previous_headings":"","what":"Step 4: add diagnosis data","title":"Building the data skeleton (skeleton1_create)","text":"Hospital diagnoses core epidemiological studies:","code":"# Load and prepare diagnosis data fake_inpatient_diagnoses <- swereg::fake_inpatient_diagnoses |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"indatum\") #> Found additional date columns not in date_columns: utdatum. Consider adding them for automatic date parsing. fake_outpatient_diagnoses <- swereg::fake_outpatient_diagnoses |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"indatum\")  diagnoses_combined <- data.table::rbindlist(list(   fake_inpatient_diagnoses,   fake_outpatient_diagnoses ), use.names = TRUE, fill = TRUE)  # Define diagnosis patterns to search for (^ prefix automatically added) diagnosis_patterns <- list(   \"depression\" = c(\"F32\", \"F33\"),   \"anxiety\" = c(\"F40\", \"F41\"),    \"gender_dysphoria\" = c(\"F64\"),   \"cardiovascular\" = c(\"I10\", \"I20\", \"I21\") )  # Add diagnoses to skeleton swereg::add_diagnoses(   skeleton,   diagnoses_combined,   id_name = \"lopnr\",   diags = diagnosis_patterns )  # Check results diag_vars <- names(diagnosis_patterns) for(var in diag_vars) {   count <- sum(skeleton[[var]], na.rm = TRUE)   cat(\"-\", var, \":\", count, \"positive cases\\n\") } #> - depression : 391 positive cases #> - anxiety : 359 positive cases #> - gender_dysphoria : 477 positive cases #> - cardiovascular : 240 positive cases"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"step-5-add-prescription-data","dir":"Articles","previous_headings":"","what":"Step 5: add prescription data","title":"Building the data skeleton (skeleton1_create)","text":"Medication data treatment duration ATC code patterns:","code":"# Load prescription data fake_prescriptions <- swereg::fake_prescriptions |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"edatum\")  # Define drug patterns (ATC codes, ^ prefix automatically added) drug_patterns <- list(   \"antidepressants\" = c(\"N06A\"),   \"hormones\" = c(\"G03\"),   \"cardiovascular_drugs\" = c(\"C07\", \"C08\", \"C09\") )  # Add prescriptions to skeleton swereg::add_rx(   skeleton,   fake_prescriptions,   id_name = \"p444_lopnr_personnr\",   rxs = drug_patterns ) #> 2025-12-24 07:39:24.618786 antidepressants #> 2025-12-24 07:39:24.965488 hormones #> 2025-12-24 07:39:25.625948 cardiovascular_drugs  # Check prescription usage rx_vars <- names(drug_patterns) for(var in rx_vars) {   count <- sum(skeleton[[var]], na.rm = TRUE)   cat(\"-\", var, \":\", count, \"prescription periods\\n\") } #> - antidepressants : 3789 prescription periods #> - hormones : 15402 prescription periods #> - cardiovascular_drugs : 2143 prescription periods"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"step-6-add-surgical-operation-data","dir":"Articles","previous_headings":"","what":"Step 6: add surgical operation data","title":"Building the data skeleton (skeleton1_create)","text":"Surgical procedures hospital records:","code":"# Add operations (using default gender-affirming surgery codes) swereg::add_operations(skeleton, fake_inpatient_diagnoses, \"lopnr\")  # Check operation counts operation_vars <- grep(\"^op_\", names(skeleton), value = TRUE) cat(\"Operation variables added:\", length(operation_vars), \"\\n\") #> Operation variables added: 9 for(var in operation_vars[1:3]) {  # Show first 3   count <- sum(skeleton[[var]], na.rm = TRUE)   cat(\"-\", var, \":\", count, \"procedures\\n\") } #> - op_afab_mastectomy : 158 procedures #> - op_afab_breast_reconst_and_other_breast_ops : 0 procedures #> - op_afab_penis_test_prosth : 0 procedures"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"step-7-add-cause-of-death-data","dir":"Articles","previous_headings":"","what":"Step 7: add cause of death data","title":"Building the data skeleton (skeleton1_create)","text":"mortality studies:","code":"# Load cause of death data fake_cod <- swereg::fake_cod |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"dodsdat\")  # Define cause of death patterns (^ prefix automatically added) cod_patterns <- list(   \"cardiovascular_death\" = c(\"I21\", \"I22\"),   \"external_causes\" = c(\"X60\", \"X70\") )  # Add to skeleton swereg::add_cods(   skeleton,   fake_cod,   id_name = \"lopnr\",   cods = cod_patterns )  # Check mortality cod_vars <- names(cod_patterns) for(var in cod_vars) {   count <- sum(skeleton[[var]], na.rm = TRUE)   cat(\"-\", var, \":\", count, \"deaths\\n\") } #> - cardiovascular_death : 14 deaths #> - external_causes : 7 deaths"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"completed-skeleton1_create","dir":"Articles","previous_headings":"","what":"Completed skeleton1_create","title":"Building the data skeleton (skeleton1_create)","text":"completed skeleton1_create now contains raw registry data integrated time structure:","code":"cat(\"Final skeleton dimensions:\", nrow(skeleton), \"rows,\", ncol(skeleton), \"columns\\n\") #> Final skeleton dimensions: 430000 rows, 27 columns  # Example: Show data for one person person_data <- skeleton[id == fake_person_ids[1] & isoyear == 2018 & !is.na(isoyearweek)] cat(\"\\nExample data for person\", fake_person_ids[1], \"in 2018 (first 6 weeks):\\n\") #>  #> Example data for person 1 in 2018 (first 6 weeks): print(head(person_data[, .(id, isoyearweek, depression, antidepressants, cardiovascular)])) #> Key: <id, isoyearweek> #>       id isoyearweek depression antidepressants cardiovascular #>    <int>      <char>     <lgcl>          <lgcl>         <lgcl> #> 1:     1     2018-01      FALSE           FALSE          FALSE #> 2:     1     2018-02      FALSE           FALSE          FALSE #> 3:     1     2018-03      FALSE           FALSE          FALSE #> 4:     1     2018-04      FALSE           FALSE          FALSE #> 5:     1     2018-05      FALSE           FALSE          FALSE #> 6:     1     2018-06      FALSE           FALSE          FALSE"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"key-principles-for-skeleton1_create","dir":"Articles","previous_headings":"","what":"Key principles for skeleton1_create","title":"Building the data skeleton (skeleton1_create)","text":"Always use make_lowercase_names() reading registry data Sequential integration: Add data types logical order Pattern matching: Use regex patterns medical codes (^ prefix automatically added) Time structure: Leverage ISO year-weeks precise temporal analysis Raw data focus: skeleton1_create integration, cleaning","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"understanding-the-output","dir":"Articles","previous_headings":"","what":"Understanding the output","title":"Building the data skeleton (skeleton1_create)","text":"skeleton1_create output several important characteristics: Mixed time granularity: weekly (is_isoyear == FALSE) yearly (is_isoyear == TRUE) rows Boolean variables: diagnosis, prescription, operation variables TRUE/FALSE Time alignment: Events aligned ISO year-weeks consistency","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton1-create.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next steps","title":"Building the data skeleton (skeleton1_create)","text":"skeleton1_create provides foundation subsequent analysis. raw data now integrated time-structured framework, ready cleaning variable derivation. Next stage: See “Cleaning deriving variables (skeleton2_clean)” vignette learn clean data create analysis-ready variables. Production workflows: large-scale processing, see “Production analysis workflows (skeleton3_analyze)” vignette.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Cleaning and deriving variables (skeleton2_clean)","text":"vignette demonstrates skeleton2_clean - second stage swereg workflow raw integrated data cleaned analysis-ready variables created. Prerequisites: Complete “Building data skeleton (skeleton1_create)” vignette first, stage builds directly skeleton1_create output.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"what-is-skeleton2_clean","dir":"Articles","previous_headings":"","what":"What is skeleton2_clean?","title":"Cleaning and deriving variables (skeleton2_clean)","text":"skeleton2_clean stage focuses : Data cleaning: Using data within skeleton (external joins) Variable derivation: Creating composite indicators summary variables Quality filters: Removing invalid observations applying study criteria Analysis preparation: Creating variables ready statistical modeling stage transforms raw integrated data clean, analysis-ready variables.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"step-1-load-skeleton1_create-output","dir":"Articles","previous_headings":"","what":"Step 1: load skeleton1_create output","title":"Cleaning and deriving variables (skeleton2_clean)","text":"Note: vignette assumes completed skeleton1_create (see “Building data skeleton” vignette). demonstration, ’ll create minimal skeleton:","code":"# Quick skeleton setup for demonstration skeleton <- swereg::create_skeleton(swereg::fake_person_ids, \"2015-01-01\", \"2020-12-31\")  # Add minimal data for demonstration fake_demographics <- swereg::fake_demographics |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"fodelseman\") swereg::add_onetime(skeleton, fake_demographics, id_name = \"lopnr\")  fake_inpatient_diagnoses <- swereg::fake_inpatient_diagnoses |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"indatum\") #> Found additional date columns not in date_columns: utdatum. Consider adding them for automatic date parsing. swereg::add_diagnoses(skeleton, fake_inpatient_diagnoses, id_name = \"lopnr\",                       diags = list(                        \"depression\" = c(\"F32\", \"F33\"),                        \"anxiety\" = c(\"F40\", \"F41\"),                         \"gender_dysphoria\" = c(\"F64\"),                        \"psychosis\" = c(\"F20\", \"F25\")                      ))  # Add prescriptions for treatment variables fake_prescriptions <- swereg::fake_prescriptions |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"edatum\") swereg::add_rx(skeleton, fake_prescriptions, id_name = \"p444_lopnr_personnr\",               rxs = list(                 \"antidepressants\" = c(\"N06A\"),                 \"antipsychotics\" = c(\"N05A\"),                 \"hormones\" = c(\"G03\")               )) #> 2025-12-24 07:39:29.48616 antidepressants #> 2025-12-24 07:39:29.81651 antipsychotics #> 2025-12-24 07:39:30.139469 hormones  # Add cause of death data  fake_cod <- swereg::fake_cod |>   data.table::copy() |>   swereg::make_lowercase_names(date_columns = \"dodsdat\") swereg::add_cods(skeleton, fake_cod, id_name = \"lopnr\",                 cods = list(                   \"external_death\" = c(\"X60\", \"X70\"),                   \"cardiovascular_death\" = c(\"I21\", \"I22\")                 ))  cat(\"skeleton1_create completed:\", nrow(skeleton), \"rows,\", ncol(skeleton), \"columns\\n\") #> skeleton1_create completed: 430000 rows, 17 columns"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"step-2-data-cleaning-operations","dir":"Articles","previous_headings":"","what":"Step 2: data cleaning operations","title":"Cleaning and deriving variables (skeleton2_clean)","text":"Now clean derive variables using data within skeleton:","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"create-age-variable","dir":"Articles","previous_headings":"Step 2: data cleaning operations","what":"Create age variable","title":"Cleaning and deriving variables (skeleton2_clean)","text":"","code":"# Create age variable skeleton[, birth_year := as.numeric(substr(fodelseman, 1, 4))] skeleton[, age := isoyear - birth_year]  cat(\"Age variable created\\n\") #> Age variable created"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"create-mental-health-composite-variables","dir":"Articles","previous_headings":"Step 2: data cleaning operations","what":"Create mental health composite variables","title":"Cleaning and deriving variables (skeleton2_clean)","text":"","code":"# Create mental health composite variables skeleton[, any_mental_health := depression | anxiety | psychosis] skeleton[, severe_mental_illness := psychosis | gender_dysphoria]  # Check mental health prevalence cat(\"Any mental health condition:\", sum(skeleton$any_mental_health, na.rm = TRUE), \"person-periods\\n\") #> Any mental health condition: 640 person-periods cat(\"Severe mental illness:\", sum(skeleton$severe_mental_illness, na.rm = TRUE), \"person-periods\\n\") #> Severe mental illness: 498 person-periods"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"create-medication-concordance-variables","dir":"Articles","previous_headings":"Step 2: data cleaning operations","what":"Create medication concordance variables","title":"Cleaning and deriving variables (skeleton2_clean)","text":"","code":"# Create medication concordance variables skeleton[, depression_treated := depression & antidepressants] skeleton[, psychosis_treated := psychosis & antipsychotics]  # Check treatment patterns cat(\"Depression with treatment:\", sum(skeleton$depression_treated, na.rm = TRUE), \"periods\\n\") #> Depression with treatment: 2 periods cat(\"Psychosis with treatment:\", sum(skeleton$psychosis_treated, na.rm = TRUE), \"periods\\n\") #> Psychosis with treatment: 2 periods"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"create-life-stage-variables","dir":"Articles","previous_headings":"Step 2: data cleaning operations","what":"Create life stage variables","title":"Cleaning and deriving variables (skeleton2_clean)","text":"","code":"# Create life stage variables skeleton[, life_stage := fcase(   age < 18, \"child\",   age >= 18 & age < 65, \"adult\",    age >= 65, \"elderly\",   default = \"unknown\" )]  # Check life stage distribution cat(\"Life stage distribution:\\n\") #> Life stage distribution: print(table(skeleton[is_isoyear == TRUE]$life_stage, useNA = \"ifany\")) #>  #>   adult   child elderly  #>   22010   93975      15"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"create-outcome-variables","dir":"Articles","previous_headings":"Step 2: data cleaning operations","what":"Create outcome variables","title":"Cleaning and deriving variables (skeleton2_clean)","text":"","code":"# Create outcome variables skeleton[, death_any := external_death | cardiovascular_death]  cat(\"Any death:\", sum(skeleton$death_any, na.rm = TRUE), \"deaths\\n\") #> Any death: 19 deaths"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"step-3-quality-filters-and-validation","dir":"Articles","previous_headings":"","what":"Step 3: quality filters and validation","title":"Cleaning and deriving variables (skeleton2_clean)","text":"Apply study criteria quality filters:","code":"# Filter to valid ages and reasonable time periods cat(\"Before filtering:\", nrow(skeleton), \"rows\\n\") #> Before filtering: 430000 rows  skeleton <- skeleton[age >= 0 & age <= 100] skeleton <- skeleton[isoyear >= 2015]  # Remove historical rows  cat(\"After filtering:\", nrow(skeleton), \"rows\\n\") #> After filtering: 315000 rows"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"step-4-create-study-design-variables","dir":"Articles","previous_headings":"","what":"Step 4: create study design variables","title":"Cleaning and deriving variables (skeleton2_clean)","text":"Create variables case-control cohort study designs:","code":"# Create registry tag variables (simulate case-control study) skeleton[, register_tag := fcase(   gender_dysphoria == TRUE, \"case\",   id %% 3 == 0, \"control_matched\",   default = \"control_population\" )]  # Create shared case variables (for matched studies) # Find first gender dysphoria diagnosis for cases gd_first <- skeleton[gender_dysphoria == TRUE & register_tag == \"case\",                       .(first_gd_year = min(isoyear, na.rm = TRUE)),                       by = .(id)]  # Add to skeleton skeleton[gd_first, on = \"id\", first_gd_year := first_gd_year]  # For controls, assign their matched case's first GD year (simplified) skeleton[register_tag != \"case\", first_gd_year := 2016]  # Simplified for demo  cat(\"Study design variables created\\n\") #> Study design variables created print(table(skeleton[is_isoyear == TRUE]$register_tag)) #>  #>    control_matched control_population  #>                333                667"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"step-5-remove-temporary-variables","dir":"Articles","previous_headings":"","what":"Step 5: remove temporary variables","title":"Cleaning and deriving variables (skeleton2_clean)","text":"Clean intermediate variables:","code":"# Remove temporary variables skeleton[, c(\"fodelseman\", \"birth_year\") := NULL]  cat(\"skeleton2_clean completed:\", nrow(skeleton), \"rows,\", ncol(skeleton), \"columns\\n\") #> skeleton2_clean completed: 315000 rows, 25 columns"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"cleaned-dataset-summary","dir":"Articles","previous_headings":"","what":"Cleaned dataset summary","title":"Cleaning and deriving variables (skeleton2_clean)","text":"cleaned skeleton2 now contains derived variables ready analysis:","code":"# Show structure cat(\"Variables:\", paste(names(skeleton), collapse = \", \"), \"\\n\") #> Variables: id, isoyear, isoyearweek, is_isoyear, isoyearweeksun, personyears, doddatum, depression, anxiety, gender_dysphoria, psychosis, antidepressants, antipsychotics, hormones, external_death, cardiovascular_death, age, any_mental_health, severe_mental_illness, depression_treated, psychosis_treated, life_stage, death_any, register_tag, first_gd_year  # Example analysis: Depression prevalence by life stage (filter to years with data) depression_summary <- skeleton[is_isoyear == TRUE & isoyear >= 2015, .(   n_person_years = .N,   depression_prev = mean(depression, na.rm = TRUE),   treatment_rate = ifelse(sum(depression, na.rm = TRUE) > 0,                          mean(depression_treated[depression == TRUE], na.rm = TRUE),                          NA_real_) ), by = .(life_stage, register_tag)]  print(depression_summary[n_person_years > 0])  # Only show non-empty groups #>    life_stage       register_tag n_person_years depression_prev treatment_rate #>        <char>             <char>          <int>           <num>          <num> #> 1:      child control_population             80               0             NA #> 2:      adult control_population            579               0             NA #> 3:      adult    control_matched            282               0             NA #> 4:    elderly    control_matched              7               0             NA #> 5:      child    control_matched             44               0             NA #> 6:    elderly control_population              8               0             NA # Example: Mental health treatment patterns (filter to valid data) treatment_summary <- skeleton[any_mental_health == TRUE & is_isoyear == TRUE & !is.na(register_tag), .(   antidepressant_use = mean(antidepressants, na.rm = TRUE),   antipsychotic_use = mean(antipsychotics, na.rm = TRUE),   hormone_use = mean(hormones, na.rm = TRUE),   mean_age = mean(age, na.rm = TRUE),   n_observations = .N ), by = register_tag]  print(treatment_summary[n_observations > 0])  # Only show groups with data #> Empty data.table (0 rows and 6 cols): register_tag,antidepressant_use,antipsychotic_use,hormone_use,mean_age,n_observations"},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"data-cleaning-strategy","dir":"Articles","previous_headings":"Key principles for skeleton2_clean","what":"Data cleaning strategy","title":"Cleaning and deriving variables (skeleton2_clean)","text":"Self-contained: skeleton2_clean uses data within skeleton Derived variables: Create analysis variables raw data Quality filters: Remove invalid observations Clinical indicators: Create meaningful composite variables","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"variable-creation-patterns","dir":"Articles","previous_headings":"Key principles for skeleton2_clean","what":"Variable creation patterns","title":"Cleaning and deriving variables (skeleton2_clean)","text":"Composite indicators: Combine multiple boolean variables (e.g., any_mental_health) Treatment concordance: Match diagnoses treatments (e.g., depression_treated) Life course variables: Create age-based categories life stages Study design variables: Create case/control indicators matched cohort variables","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"understanding-the-skeleton2_clean-output","dir":"Articles","previous_headings":"","what":"Understanding the skeleton2_clean output","title":"Cleaning and deriving variables (skeleton2_clean)","text":"skeleton2_clean output contains: Clean variables: Validated age, filtered time periods Derived indicators: Composite mental health variables, treatment patterns Study variables: Case-control tags, cohort definitions Summary measures: Person-level aggregations annual data Analysis-ready format: Variables ready statistical modeling","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton2-clean.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next steps","title":"Cleaning and deriving variables (skeleton2_clean)","text":"skeleton2_clean provides clean, analysis-ready variables statistical modeling. data validated, derived variables created, study design implemented. large datasets: huge datasets (>100,000 individuals) limited RAM, see “Batching (skeleton3_analyze)” vignette learn memory-efficient processing techniques. Analysis ready: analyses, can proceed directly descriptive statistics, regression modeling, survival analysis using cleaned skeleton2 data.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Batching (skeleton3_analyze)","text":"vignette demonstrates skeleton3_analyze - memory-efficient batching techniques processing huge datasets limited RAM. Important note: stage required large datasets (>100,000 individuals) insufficient RAM. analyses, can use cleaned skeleton2_clean output directly statistical modeling. Prerequisites: Complete “Cleaning deriving variables (skeleton2_clean)” vignette first, stage builds skeleton2_clean output.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"what-is-skeleton3_analyze","dir":"Articles","previous_headings":"","what":"What is skeleton3_analyze?","title":"Batching (skeleton3_analyze)","text":"skeleton3_analyze stage focuses : Final data aggregation: Weekly→yearly data collapsing needed Analysis dataset creation: Optimized specific research questions Memory-efficient processing: Batching strategies large populations Production workflows: Scalable approaches hundreds thousands individuals stage creates final analysis datasets ready statistical modeling.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"when-to-use-batching-strategies","dir":"Articles","previous_headings":"","what":"When to use batching strategies","title":"Batching (skeleton3_analyze)","text":"Use batching strategies : Study population > 100,000 individuals Memory constraints: Limited RAM full dataset Processing time: Long-running operations benefit parallel processing File size management: Breaking large datasets manageable chunks","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"setup-memory-efficient-workflow","dir":"Articles","previous_headings":"","what":"Setup: memory-efficient workflow","title":"Batching (skeleton3_analyze)","text":"","code":"# Setup for batched processing BATCH_SIZE <- 50  # Small for demonstration - use 1000-5000 for real studies OUTPUT_DIR <- tempdir()  # Use temporary directory for vignette  # Setup for demonstration (see skeleton1_create vignette for detailed data integration) # For batching, we organize data into large_data_files list for memory management large_data_files <- list(   \"fake_demographics\" = swereg::fake_demographics |>     data.table::copy() |>     swereg::make_lowercase_names(date_columns = \"fodelseman\"),   \"fake_annual_family\" = swereg::fake_annual_family |>     swereg::make_lowercase_names(),   \"fake_inpatient_diagnoses\" = swereg::fake_inpatient_diagnoses |>     data.table::copy() |>     swereg::make_lowercase_names(date_columns = \"indatum\"),   \"fake_outpatient_diagnoses\" = swereg::fake_outpatient_diagnoses |>     data.table::copy() |>     swereg::make_lowercase_names(date_columns = \"indatum\"),   \"fake_prescriptions\" = swereg::fake_prescriptions |>     data.table::copy() |>     swereg::make_lowercase_names(date_columns = \"edatum\"),   \"fake_cod\" = swereg::fake_cod |>     data.table::copy() |>     swereg::make_lowercase_names(date_columns = \"dodsdat\") ) #> Found additional date columns not in date_columns: utdatum. Consider adding them for automatic date parsing.  cat(\"Data loaded and preprocessed - ready for batched processing\\n\") #> Data loaded and preprocessed - ready for batched processing"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"the-three-stage-batched-workflow","dir":"Articles","previous_headings":"","what":"The three-stage batched workflow","title":"Batching (skeleton3_analyze)","text":"skeleton1_create batches: Process raw data integration chunks, save skeleton1 files skeleton2_clean batches: Load skeleton1 files, clean data, save skeleton2 files skeleton3_analyze: Combine skeleton2 files final analysis dataset","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"create-batch-processing-function","dir":"Articles","previous_headings":"Phase 1: skeleton1_create (batched data integration)","what":"Create batch processing function","title":"Batching (skeleton3_analyze)","text":"","code":"skeleton1_create_batch <- function(batch_ids, batch_number, large_data_files) {   # Declare variables for data.table non-standard evaluation   lopnr <- p444_lopnr_personnr <- NULL      cat(\"Processing batch\", batch_number, \"with\", length(batch_ids), \"individuals\\n\")      # Create skeleton for this batch   skeleton <- swereg::create_skeleton(     ids = batch_ids,     date_min = \"2015-01-01\",     date_max = \"2018-12-31\"  # Shorter period for demonstration   )      # Add demographics   demographics_subset <- large_data_files[[\"fake_demographics\"]][lopnr %in% batch_ids]   if (nrow(demographics_subset) > 0) {     swereg::add_onetime(skeleton, demographics_subset, id_name = \"lopnr\")   }      # Add annual data   annual_subset <- large_data_files[[\"fake_annual_family\"]][lopnr %in% batch_ids]   if (nrow(annual_subset) > 0) {     swereg::add_annual(skeleton, annual_subset, id_name = \"lopnr\", isoyear = 2015)   }      # Add diagnoses   diagnoses_subset <- rbindlist(list(     large_data_files[[\"fake_inpatient_diagnoses\"]][lopnr %in% batch_ids],     large_data_files[[\"fake_outpatient_diagnoses\"]][lopnr %in% batch_ids]   ), use.names = TRUE, fill = TRUE)      if (nrow(diagnoses_subset) > 0) {     swereg::add_diagnoses(       skeleton,       diagnoses_subset,       id_name = \"lopnr\",       diags = list(         \"depression\" = c(\"F32\", \"F33\"),         \"anxiety\" = c(\"F40\", \"F41\"),         \"gender_dysphoria\" = c(\"F64\"),         \"psychosis\" = c(\"F20\", \"F25\")       )     )   }      # Add prescriptions   prescriptions_subset <- large_data_files[[\"fake_prescriptions\"]][p444_lopnr_personnr %in% batch_ids]   if (nrow(prescriptions_subset) > 0) {     swereg::add_rx(       skeleton,       prescriptions_subset,       id_name = \"p444_lopnr_personnr\",       rxs = list(         \"antidepressants\" = c(\"N06A\"),         \"antipsychotics\" = c(\"N05A\"),         \"hormones\" = c(\"G03\")       )     )   }      # Add cause of death   cod_subset <- large_data_files[[\"fake_cod\"]][lopnr %in% batch_ids]   if (nrow(cod_subset) > 0) {     swereg::add_cods(       skeleton,       cod_subset,       id_name = \"lopnr\",       cods = list(         \"external_death\" = c(\"X60\", \"X70\"),         \"cardiovascular_death\" = c(\"I21\", \"I22\")       )     )   }      # Save batch using qs (much faster than RDS)   output_file <- file.path(OUTPUT_DIR, paste0(\"skeleton1_create_\", batch_number, \".qs\"))   qs::qsave(skeleton, output_file)      cat(\"Saved skeleton1_create\", batch_number, \":\", nrow(skeleton), \"rows\\n\")   return(output_file) }"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"process-skeleton1_create-in-batches","dir":"Articles","previous_headings":"Phase 1: skeleton1_create (batched data integration)","what":"Process skeleton1_create in batches","title":"Batching (skeleton3_analyze)","text":"","code":"# Process first 100 individuals in 2 batches data(\"fake_person_ids\", package = \"swereg\") ids_subset <- fake_person_ids[1:100] id_batches <- csutil::easy_split(ids_subset, BATCH_SIZE)  skeleton1_files <- vector(\"character\", length(id_batches)) for (i in seq_along(id_batches)) {   skeleton1_files[i] <- skeleton1_create_batch(id_batches[[i]], i, large_data_files) } #> Processing batch 1 with 50 individuals #> 2025-12-24 07:39:35.224006 antidepressants #> 2025-12-24 07:39:35.322848 antipsychotics #> 2025-12-24 07:39:35.402049 hormones #> Saved skeleton1_create 1 : 16300 rows #> Processing batch 2 with 50 individuals #> 2025-12-24 07:39:35.747171 antidepressants #> 2025-12-24 07:39:35.830899 antipsychotics #> 2025-12-24 07:39:36.035571 hormones #> Saved skeleton1_create 2 : 16300 rows  cat(\"skeleton1_create phase completed for\", length(id_batches), \"batches\\n\") #> skeleton1_create phase completed for 2 batches  # CRITICAL: Remove large datasets from memory # This is the key benefit of organizing data into large_data_files -  # easy cleanup of \"the big lump of data\" after skeleton1_create is complete rm(large_data_files) gc()  # Force garbage collection #>           used (Mb) gc trigger  (Mb) max used  (Mb) #> Ncells 1435350 76.7    2616157 139.8  2616157 139.8 #> Vcells 5824875 44.5   12552320  95.8  9887050  75.5  cat(\"Large datasets removed from memory\\n\") #> Large datasets removed from memory"},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"create-cleaning-function","dir":"Articles","previous_headings":"Phase 2: skeleton2_clean (batched data cleaning)","what":"Create cleaning function","title":"Batching (skeleton3_analyze)","text":"","code":"skeleton2_clean_batch <- function(batch_number) {   cat(\"Cleaning batch\", batch_number, \"\\n\")      # Load skeleton1 for this batch   input_file <- file.path(OUTPUT_DIR, paste0(\"skeleton1_create_\", batch_number, \".qs\"))   skeleton <- qs::qread(input_file)      # CLEANING OPERATIONS (using only data within skeleton)      # 1. Create age variable   skeleton[, birth_year := as.numeric(substr(fodelseman, 1, 4))]   skeleton[, age := isoyear - birth_year]      # 2. Create mental health composite variables   skeleton[, any_mental_health := depression | anxiety | psychosis]   skeleton[, severe_mental_illness := psychosis | gender_dysphoria]      # 3. Create medication concordance variables   skeleton[, depression_treated := depression & antidepressants]   skeleton[, psychosis_treated := psychosis & antipsychotics]      # 4. Create life stage variables   skeleton[, life_stage := fcase(     age < 18, \"child\",     age >= 18 & age < 65, \"adult\",      age >= 65, \"elderly\",     default = \"unknown\"   )]      # 5. Create outcome variables   skeleton[, death_any := external_death | cardiovascular_death]      # 6. Filter to valid ages and reasonable time periods   skeleton <- skeleton[age >= 0 & age <= 100]   skeleton <- skeleton[isoyear >= 2015]  # Remove historical rows      # 7. Create person-level summaries for annual data   if (skeleton[, any(is_isoyear == TRUE)]) {     skeleton[is_isoyear == TRUE, n_mental_health_year := sum(c(depression, anxiety, psychosis), na.rm = TRUE), by = .(id, isoyear)]     skeleton[is_isoyear == TRUE, treatment_adherence := mean(c(depression_treated, psychosis_treated), na.rm = TRUE), by = .(id, isoyear)]   }      # 8. Create registry tag variables (simulate case-control study)   skeleton[, register_tag := fcase(     gender_dysphoria == TRUE, \"case\",     id %% 3 == 0, \"control_matched\",     default = \"control_population\"   )]      # 9. Create shared case variables (for matched studies)   # Find first gender dysphoria diagnosis for cases   gd_first <- skeleton[gender_dysphoria == TRUE & register_tag == \"case\",                         .(first_gd_year = min(isoyear, na.rm = TRUE)),                         by = .(id)]      # Add to skeleton   skeleton[gd_first, on = \"id\", first_gd_year := first_gd_year]      # For controls, assign their matched case's first GD year (simplified)   skeleton[register_tag != \"case\", first_gd_year := 2016]  # Simplified for demo      # 10. Remove temporary variables   skeleton[, c(\"fodelseman\", \"birth_year\") := NULL]      # Save cleaned skeleton using qs   output_file <- file.path(OUTPUT_DIR, paste0(\"skeleton2_clean_\", batch_number, \".qs\"))   qs::qsave(skeleton, output_file)      cat(\"Cleaned skeleton2_clean\", batch_number, \":\", nrow(skeleton), \"rows,\", ncol(skeleton), \"columns\\n\")   return(output_file) }"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"process-skeleton2_clean-in-batches","dir":"Articles","previous_headings":"Phase 2: skeleton2_clean (batched data cleaning)","what":"Process skeleton2_clean in batches","title":"Batching (skeleton3_analyze)","text":"","code":"# Process all batches for skeleton2_clean skeleton2_files <- vector(\"character\", length(id_batches)) for (i in seq_along(id_batches)) {   skeleton2_files[i] <- skeleton2_clean_batch(i) } #> Cleaning batch 1  #> Cleaned skeleton2_clean 1 : 10550 rows, 28 columns #> Cleaning batch 2  #> Cleaned skeleton2_clean 2 : 10550 rows, 28 columns  cat(\"skeleton2_clean phase completed\\n\") #> skeleton2_clean phase completed"},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"create-analysis-dataset-from-all-batches","dir":"Articles","previous_headings":"Phase 3: skeleton3_analyze (final analysis dataset)","what":"Create analysis dataset from all batches","title":"Batching (skeleton3_analyze)","text":"batching becomes essential - skeleton3 reduces data ’s needed analysis, dramatically reducing memory usage. Key concept: weekly→yearly data aggregation skeleton contains weekly yearly rows. skeleton3_analyze, collapse weekly data yearly data using swereg::max_with_infinite_as_na() answer question: “anything happen year?” diagnoses: person depression point year? treatments: person receive antidepressants point year? events: relevant event occur year? aggregation creates person-year level data suitable epidemiological analysis.","code":"skeleton3_analyze <- function(skeleton2_files) {   cat(\"Creating analysis dataset from\", length(skeleton2_files), \"batches\\n\")      # Load all cleaned batches   all_batches <- vector(\"list\", length(skeleton2_files))   for (i in seq_along(skeleton2_files)) {     skeleton <- qs::qread(skeleton2_files[i])          # Extract analysis variables (collapse weekly data to yearly)     # Use max_with_infinite_as_na because we're aggregating weekly data to yearly:     # \"did anything happen this year?\"     analysis_data <- skeleton[       .(         # Demographic variables         age = swereg::first_non_na(age),         life_stage = swereg::first_non_na(life_stage),                  # Outcome variables - use max to detect \"did anything happen this year?\"         any_mental_health = swereg::max_with_infinite_as_na(any_mental_health),         severe_mental_illness = swereg::max_with_infinite_as_na(severe_mental_illness),         depression = swereg::max_with_infinite_as_na(depression),         anxiety = swereg::max_with_infinite_as_na(anxiety),         psychosis = swereg::max_with_infinite_as_na(psychosis),         gender_dysphoria = swereg::max_with_infinite_as_na(gender_dysphoria),                  # Treatment variables         antidepressants = swereg::max_with_infinite_as_na(antidepressants),         antipsychotics = swereg::max_with_infinite_as_na(antipsychotics),         hormones = swereg::max_with_infinite_as_na(hormones),                  # Derived variables         depression_treated = swereg::max_with_infinite_as_na(depression_treated),         psychosis_treated = swereg::max_with_infinite_as_na(psychosis_treated),                  # Mortality         death_any = swereg::max_with_infinite_as_na(death_any),                  # Study design variables         first_gd_year = swereg::first_non_na(first_gd_year),                  # Summary variables         n_mental_health_year = swereg::first_non_na(n_mental_health_year),         treatment_adherence = swereg::first_non_na(treatment_adherence)       ),       by = .(id, study_year = isoyear, register_tag)     ]          all_batches[[i]] <- analysis_data   }      # Combine all batches   final_analysis <- rbindlist(all_batches)      # Save final analysis dataset   output_file <- file.path(OUTPUT_DIR, \"skeleton3_analyze.qs\")   qs::qsave(final_analysis, output_file)      cat(\"Saved skeleton3_analyze:\", nrow(final_analysis), \"person-years\\n\")      return(final_analysis) }  # Create final analysis dataset analysis_data <- skeleton3_analyze(skeleton2_files) #> Creating analysis dataset from 2 batches #> Warning in `[.data.table`(skeleton, .(age = swereg::first_non_na(age), #> life_stage = swereg::first_non_na(life_stage), : Ignoring by/keyby because 'j' #> is not supplied #> Warning in `[.data.table`(skeleton, .(age = swereg::first_non_na(age), #> life_stage = swereg::first_non_na(life_stage), : Ignoring by/keyby because 'j' #> is not supplied #> Saved skeleton3_analyze: 2 person-years  cat(\"Analysis dataset created:\", nrow(analysis_data), \"person-years\\n\") #> Analysis dataset created: 2 person-years cat(\"Variables:\", ncol(analysis_data), \"\\n\") #> Variables: 43 cat(\"Study population breakdown:\\n\") #> Study population breakdown: print(table(analysis_data$register_tag)) #> < table of extent 0 >"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"analysis-dataset-summary","dir":"Articles","previous_headings":"","what":"Analysis dataset summary","title":"Batching (skeleton3_analyze)","text":"final skeleton3_analyze contains analysis-ready data:","code":"# Show structure str(analysis_data) #> Classes 'data.table' and 'data.frame':   2 obs. of  43 variables: #>  $ id                     : int  11 48 #>  $ isoyear                : int  NA NA #>  $ isoyearweek            : chr  \"child\" \"adult\" #>  $ is_isoyear             : logi  NA NA #>  $ isoyearweeksun         : Date, format: NA NA #>  $ personyears            : num  NA NA #>  $ doddatum               : chr  NA NA #>  $ famtyp                 : chr  NA NA #>  $ depression             : logi  NA NA #>  $ anxiety                : logi  NA NA #>  $ gender_dysphoria       : logi  NA NA #>  $ psychosis              : logi  NA NA #>  $ antidepressants        : logi  NA NA #>  $ antipsychotics         : logi  NA NA #>  $ hormones               : logi  NA NA #>  $ external_death         : logi  NA NA #>  $ cardiovascular_death   : logi  NA NA #>  $ age                    : num  NA NA #>  $ any_mental_health      : logi  NA NA #>  $ severe_mental_illness  : logi  NA NA #>  $ depression_treated     : logi  NA NA #>  $ psychosis_treated      : logi  NA NA #>  $ life_stage             : chr  NA NA #>  $ death_any              : logi  NA NA #>  $ n_mental_health_year   : int  NA NA #>  $ treatment_adherence    : num  NA NA #>  $ register_tag           : chr  NA NA #>  $ first_gd_year          : int  NA NA #>  $ i.any_mental_health    : int  1 1 #>  $ i.severe_mental_illness: int  1 1 #>  $ i.depression           : int  0 1 #>  $ i.anxiety              : int  1 1 #>  $ i.psychosis            : int  1 1 #>  $ i.gender_dysphoria     : int  1 1 #>  $ i.antidepressants      : int  1 1 #>  $ i.antipsychotics       : int  1 1 #>  $ i.hormones             : int  1 1 #>  $ i.depression_treated   : int  0 0 #>  $ i.psychosis_treated    : int  0 1 #>  $ i.death_any            : int  0 1 #>  $ i.first_gd_year        : int  2016 2016 #>  $ i.n_mental_health_year : int  0 0 #>   ..- attr(*, \"na.action\")= 'omit' int [1:10500] 2 3 4 5 6 7 8 9 10 11 ... #>  $ i.treatment_adherence  : num  0 0 #>   ..- attr(*, \"na.action\")= 'omit' int [1:10500] 2 3 4 5 6 7 8 9 10 11 ... #>  - attr(*, \".internal.selfref\")=<externalptr>  # Example analysis: Depression prevalence by register tag depression_summary <- analysis_data[, .(   n_person_years = .N,   depression_prev = mean(depression, na.rm = TRUE),   # Fix treatment rate calculation to avoid NaN   treatment_rate = ifelse(sum(depression, na.rm = TRUE) > 0,                           mean(depression_treated[depression == TRUE], na.rm = TRUE),                           NA_real_) ), by = .(register_tag)]  print(depression_summary) #>    register_tag n_person_years depression_prev treatment_rate #>          <char>          <int>           <num>          <num> #> 1:         <NA>              2             NaN             NA # Example: Mental health treatment patterns treatment_summary <- analysis_data[any_mental_health == TRUE, .(   antidepressant_use = mean(antidepressants, na.rm = TRUE),   antipsychotic_use = mean(antipsychotics, na.rm = TRUE),   hormone_use = mean(hormones, na.rm = TRUE),   mean_age = mean(age, na.rm = TRUE) ), by = register_tag]  print(treatment_summary) #> Empty data.table (0 rows and 5 cols): register_tag,antidepressant_use,antipsychotic_use,hormone_use,mean_age"},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"batch-size-optimization","dir":"Articles","previous_headings":"Memory management best practices","what":"1. Batch size optimization","title":"Batching (skeleton3_analyze)","text":"","code":"# For production studies, batch size depends on: # - Available RAM: Larger batches use more memory but fewer file operations # - Processing time: Very large batches can hit memory limits # - File system: Too many small files can slow down I/O  # Recommended batch sizes: # - 1,000-2,000 individuals for modest hardware (8-16GB RAM) # - 5,000-10,000 individuals for high-memory systems (32-64GB RAM) # - Each batch uses ~200-500MB RAM during processing"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"file-organization","dir":"Articles","previous_headings":"Memory management best practices","what":"2. File organization","title":"Batching (skeleton3_analyze)","text":"","code":"# For production studies, organize files systematically: # OUTPUT_DIR/ #   skeleton1/ #     skeleton1_create_1.qs, skeleton1_create_2.qs, ... #   skeleton2/  #     skeleton2_clean_1.qs, skeleton2_clean_2.qs, ... #   skeleton3/ #     skeleton3_analyze.qs  # Clean up strategy: # 1. Keep skeleton2 files for quality checks # 2. Remove skeleton1 files after skeleton2_clean succeeds # 3. Archive skeleton2 files after skeleton3_analyze succeeds"},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"error-handling","dir":"Articles","previous_headings":"Memory management best practices","what":"3. Error handling","title":"Batching (skeleton3_analyze)","text":"","code":"# Production workflows should include error handling skeleton1_create_batch_safe <- function(batch_ids, batch_number, large_data_files) {   tryCatch({     return(skeleton1_create_batch(batch_ids, batch_number, large_data_files))   }, error = function(e) {     cat(\"ERROR in batch\", batch_number, \":\", e$message, \"\\n\")     return(NULL)   }) }  # Check for failed batches before proceeding # failed_batches <- which(sapply(skeleton1_files, is.null)) # This allows resuming failed batch processing"},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"memory-efficiency","dir":"Articles","previous_headings":"Key batching principles","what":"Memory efficiency","title":"Batching (skeleton3_analyze)","text":"Sequential processing: Process one batch time Memory cleanup: Remove large datasets skeleton1_create Garbage collection: Use gc() batches File-based workflow: Save/load batches disk","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"data-integrity","dir":"Articles","previous_headings":"Key batching principles","what":"Data integrity","title":"Batching (skeleton3_analyze)","text":"Batch validation: Check individuals processed File verification: Ensure batch files exist skeleton3 Data consistency: Verify variables across batches","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/articles/skeleton3-analyze.html","id":"summary-the-complete-skeleton1skeleton2skeleton3-workflow","dir":"Articles","previous_headings":"","what":"Summary: the complete skeleton1→skeleton2→skeleton3 workflow","title":"Batching (skeleton3_analyze)","text":"pipeline demonstrates production-scale processing: skeleton1_create: Built time-structured framework integrated raw registry data batches skeleton2_clean: Cleaned variables created derived clinical indicators batches skeleton3_analyze: Combined batches final analysis dataset memory-efficient aggregation Key benefits: - Scalable: Handles hundreds thousands individuals - Memory-efficient: Uses large_data_files pattern systematic cleanup - Robust: File-based workflow survives interruptions - Analysis-ready: Final dataset optimized statistical modeling skeleton3_analyze output now ready epidemiological analysis, regression modeling, survival analysis.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"package proudly brought : Richard Aubrey White. Author, maintainer. See changelog contributors.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"White RA (2025). swereg: Manipulating Swedish Registry Data. R package version 25.12.24, https://github.com/papadopoulos-lab/swereg.","code":"@Manual{,   title = {swereg: Manipulating Swedish Registry Data},   author = {Richard Aubrey White},   year = {2025},   note = {R package version 25.12.24},   url = {https://github.com/papadopoulos-lab/swereg}, }"},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"swereg","dir":"","previous_headings":"","what":"Manipulating Swedish Registry Data","title":"Manipulating Swedish Registry Data","text":"swereg R package manipulating analyzing healthcare registry data epidemiological research. provides systematic three-stage framework creating longitudinal data skeletons integrating multiple health registries.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"registry-integration","dir":"","previous_headings":"","what":"Registry integration","title":"Manipulating Swedish Registry Data","text":"swereg designed healthcare registries realistic synthetic data included: Hospital registers: Diagnosis codes (ICD-10) surgical procedures Prescription registers: Medication data ATC codes treatment duration Death registers: Underlying multiple causes proper variable names Administrative data: Demographics socioeconomic data Synthetic datasets: fake_demographics, fake_inpatient_diagnoses, fake_prescriptions, fake_cod, etc.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"the-skeleton-approach","dir":"","previous_headings":"","what":"The skeleton approach","title":"Manipulating Swedish Registry Data","text":"swereg uses skeleton concept: build strong ‘bones’ (time structure) attach ‘muscles’ (data) systematically three stages: skeleton1_create - Raw data integration skeleton2_clean - Data cleaning derived variables (analysis-ready studies) skeleton3_analyze - Memory-efficient batching (needed huge datasets limited RAM)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Manipulating Swedish Registry Data","text":"Three-stage workflow: Systematic skeleton1→skeleton2→skeleton3 progression Time structure: ISO year-weeks automatic Sunday date calculation person-time calculations Smart date parsing: Handles Swedish registry dates varying precision (4/6/8 characters) Healthcare integration: Hospital diagnosis surgical procedures automatic pattern matching Prescription analysis: Prescription data treatment duration ATC code patterns Mortality data: Death registry underlying multiple causes Synthetic data: Realistic synthetic registry data development testing Scalable processing: Memory-efficient batching large populations (needed) Reproducible workflow: Standardized methodology registry-based epidemiological research","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"data-structure","dir":"","previous_headings":"Core functions","what":"Data structure","title":"Manipulating Swedish Registry Data","text":"create_skeleton() - Create longitudinal data skeleton individual IDs, time periods, person-time calculations make_lowercase_names() - Standardize column names clean date columns across datasets parse_swedish_date() - Parse Swedish registry dates varying precision (4/6/8 characters)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"data-integration","dir":"","previous_headings":"Core functions","what":"Data integration","title":"Manipulating Swedish Registry Data","text":"add_onetime() - Merge baseline/demographic data add_annual() - Add annual data specific years add_diagnoses() - Integrate healthcare diagnosis data (ICD-10) add_operations() - Add surgical procedure data add_rx() - Include prescription drug data treatment periods add_cods() - Merge cause death information","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"specialized-functions","dir":"","previous_headings":"Core functions","what":"Specialized functions","title":"Manipulating Swedish Registry Data","text":"x2023_mht_add_lmed() - Process menopausal hormone therapy prescription data","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Manipulating Swedish Registry Data","text":"can install development version swereg GitHub:","code":"# Install devtools if not already installed install.packages(\"devtools\")  # Install swereg devtools::install_github(\"papadopoulos-lab/swereg\")"},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting started","title":"Manipulating Swedish Registry Data","text":"Follow vignettes order learn skeleton approach:","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"id_1-understand-the-concept","dir":"","previous_headings":"Getting started","what":"1. Understand the concept","title":"Manipulating Swedish Registry Data","text":"Learn foundational skeleton approach works registry data analysis.","code":"vignette(\"skeleton-concept\")"},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"id_2-build-your-skeleton-skeleton1_create","dir":"","previous_headings":"Getting started","what":"2. Build your skeleton (skeleton1_create)","title":"Manipulating Swedish Registry Data","text":"Create time structure integrate raw registry data:","code":"vignette(\"skeleton1-create\") library(data.table)  # Load synthetic registry data (included with package) data(\"fake_person_ids\", package = \"swereg\") data(\"fake_demographics\", package = \"swereg\") data(\"fake_inpatient_diagnoses\", package = \"swereg\")  # Step 1: Create the skeleton (good bones) skeleton <- swereg::create_skeleton(   ids = fake_person_ids[1:100],   date_min = \"2020-01-01\",   date_max = \"2022-12-31\" )  # Step 2: Apply standardization (required for all registry data) swereg::make_lowercase_names(fake_demographics, date_column = \"fodelseman\") swereg::make_lowercase_names(fake_inpatient_diagnoses, date_column = \"indatum\")  # Step 3: Attach demographic data (muscles) demographics_subset <- fake_demographics[lopnr %in% fake_person_ids[1:100]] swereg::add_onetime(skeleton, demographics_subset, id_name = \"lopnr\")  # Step 4: Add diagnosis patterns (^ prefix automatically added) diagnosis_patterns <- list(   \"diabetes\" = c(\"E10\", \"E11\"),   \"depression\" = c(\"F32\", \"F33\") ) diagnoses_subset <- fake_inpatient_diagnoses[lopnr %in% fake_person_ids[1:100]] swereg::add_diagnoses(skeleton, diagnoses_subset, \"lopnr\", diags = diagnosis_patterns)  # Result: skeleton1_create ready for skeleton2_clean stage head(skeleton)"},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"id_3-clean-your-data-skeleton2_clean---analysis-ready-for-most-studies","dir":"","previous_headings":"Getting started","what":"3. Clean your data (skeleton2_clean) - Analysis ready for most studies","title":"Manipulating Swedish Registry Data","text":"Clean variables create derived clinical indicators using data within skeleton. analyses, final step - can proceed directly statistical modeling using skeleton2_clean output.","code":"vignette(\"skeleton2-clean\")"},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"id_4-batching-for-huge-datasets-skeleton3_analyze---optional","dir":"","previous_headings":"Getting started","what":"4. Batching for huge datasets (skeleton3_analyze) - Optional","title":"Manipulating Swedish Registry Data","text":"needed huge datasets (>100,000 individuals) limited RAM. Learn memory-efficient batching techniques. users can skip use skeleton2_clean output directly analysis.","code":"vignette(\"skeleton3-analyze\")"},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"when-do-you-need-each-stage","dir":"","previous_headings":"","what":"When do you need each stage?","title":"Manipulating Swedish Registry Data","text":"skeleton1_create: Required users - integrates raw data time structure skeleton2_clean: Required users - creates analysis-ready variables skeleton3_analyze: Optional - needed memory-constrained processing large datasets","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"key-principles","dir":"","previous_headings":"","what":"Key principles","title":"Manipulating Swedish Registry Data","text":"Sequential stages: stage builds previous one Time structure: ISO year-weeks provide precise temporal alignment Pattern matching: Automatic prefix handling medical codes Analysis flexibility: skeleton2_clean output works statistical models Memory efficiency: skeleton3_analyze provides batching RAM limited","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"typical-workflow","dir":"","previous_headings":"","what":"Typical workflow","title":"Manipulating Swedish Registry Data","text":"users follow pattern: Read vignette(“skeleton-concept”) understand approach Create skeleton1 data using skeleton1-create vignette Clean skeleton2 using skeleton2-clean vignette Analyze skeleton2 directly preferred statistical methods (glm, survival, etc.) large-scale studies memory constraints need skeleton3_analyze.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Manipulating Swedish Registry Data","text":"Complete documentation tutorials available : https://papadopoulos-lab.github.io/swereg/","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Manipulating Swedish Registry Data","text":"use swereg research, please cite:","code":"[Citation information to be added]"},{"path":"https://papadopoulos-lab.github.io/swereg/license.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Richard Aubrey White Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_annual.html","id":null,"dir":"Reference","previous_headings":"","what":"Add annual data to skeleton — add_annual","title":"Add annual data to skeleton — add_annual","text":"Merges annual data main skeleton data structure specific ISO year. function used adding data measured recorded annually, yearly income, employment status, annual health assessments.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_annual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add annual data to skeleton — add_annual","text":"","code":"add_annual(skeleton, data, id_name, isoyear)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_annual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add annual data to skeleton — add_annual","text":"skeleton data.table containing main skeleton structure id time variables data data.table containing annual data merged id_name Character string specifying name ID variable data isoyear Integer specifying ISO year data applies","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_annual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add annual data to skeleton — add_annual","text":"skeleton data.table modified reference annual data merged .   Columns data already exist skeleton prefixed \".\"","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_annual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add annual data to skeleton — add_annual","text":"","code":"# Load fake data data(\"fake_person_ids\", package = \"swereg\") data(\"fake_annual_family\", package = \"swereg\") swereg::make_lowercase_names(fake_annual_family)  # Create skeleton skeleton <- create_skeleton(fake_person_ids[1:5], \"2020-01-01\", \"2022-12-31\")  # Add annual family data for 2021 add_annual(skeleton, fake_annual_family, \"lopnr\", 2021) #>          id isoyear isoyearweek is_isoyear isoyearweeksun personyears famtyp #>       <int>   <int>      <char>     <lgcl>         <Date>       <num> <char> #>    1:     1    1900     1900-**       TRUE     1900-07-01  1.00000000   <NA> #>    2:     1    1901     1901-**       TRUE     1901-06-30  1.00000000   <NA> #>    3:     1    1902     1902-**       TRUE     1902-06-29  1.00000000   <NA> #>    4:     1    1903     1903-**       TRUE     1903-06-28  1.00000000   <NA> #>    5:     1    1904     1904-**       TRUE     1904-07-03  1.00000000   <NA> #>   ---                                                                        #> 1386:     5    2022     2022-48      FALSE     2022-12-04  0.01913876   <NA> #> 1387:     5    2022     2022-49      FALSE     2022-12-11  0.01913876   <NA> #> 1388:     5    2022     2022-50      FALSE     2022-12-18  0.01913876   <NA> #> 1389:     5    2022     2022-51      FALSE     2022-12-25  0.01913876   <NA> #> 1390:     5    2022     2022-52      FALSE     2023-01-01  0.01913876   <NA>  # Check data was added only for 2021 skeleton[isoyear == 2021 & is_isoyear == TRUE, .(id, isoyear, famtyp)] #> Empty data.table (0 rows and 3 cols): id,isoyear,famtyp"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_cods.html","id":null,"dir":"Reference","previous_headings":"","what":"Add cause of death data to skeleton — add_cods","title":"Add cause of death data to skeleton — add_cods","text":"Searches specific ICD-10 cause death codes Swedish death registry data adds corresponding boolean variables skeleton. Can search underlying cause death, multiple causes, .","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_cods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add cause of death data to skeleton — add_cods","text":"","code":"add_cods(   skeleton,   dataset,   id_name,   cod_type = \"both\",   cods = list(icd10_F64_0 = c(\"F640\"), icd10_F64_89 = c(\"F6489\"), icd10_F64_089 =     c(\"F640\", \"F648\", \"F649\")) )"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_cods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add cause of death data to skeleton — add_cods","text":"skeleton data.table containing main skeleton structure created create_skeleton dataset data.table containing death registry data cause death codes. Must columns person ID, death date (dodsdat), cause codes (ulorsak, morsak variables) id_name Character string specifying name ID variable dataset cod_type Character string specifying cause types search: \"\" (default) - Search underlying (ulorsak) multiple (morsak) causes \"underlying\" - Search underlying cause death (ulorsak) \"multiple\" - Search multiple/contributing causes (morsak variables) cods Named list ICD-10 code patterns search . Names become variable names skeleton. Patterns include \"^\" prefix (automatically added). Use exclusions \"!\" prefix. Example: list(\"cardiovascular_death\" = c(\"I21\", \"I22\"), \"external_causes\" = c(\"X60\", \"X70\"))","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_cods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add cause of death data to skeleton — add_cods","text":"skeleton data.table modified reference cause death variables added.   New boolean variables created cause pattern, TRUE cause present.","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_cods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add cause of death data to skeleton — add_cods","text":"","code":"# Load fake data data(\"fake_person_ids\", package = \"swereg\") data(\"fake_cod\", package = \"swereg\") swereg::make_lowercase_names(fake_cod, date_columns = \"dodsdat\")  # Create skeleton skeleton <- create_skeleton(fake_person_ids[1:10], \"2020-01-01\", \"2020-12-31\")  # Add cause of death data cod_patterns <- list(   \"cardiovascular_death\" = c(\"I21\", \"I22\"),   \"external_causes\" = c(\"X60\", \"X70\") ) add_cods(skeleton, fake_cod, \"lopnr\", \"both\", cod_patterns)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_diagnoses.html","id":null,"dir":"Reference","previous_headings":"","what":"Add diagnosis data to skeleton — add_diagnoses","title":"Add diagnosis data to skeleton — add_diagnoses","text":"Searches specific ICD diagnosis codes Swedish hospital registry data adds corresponding boolean variables skeleton. Can search main diagnoses main secondary diagnoses.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_diagnoses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add diagnosis data to skeleton — add_diagnoses","text":"","code":"add_diagnoses(   skeleton,   dataset,   id_name,   diag_type = \"both\",   diags = list(icd10_F64_0 = c(\"F640\"), icd10_F64_89 = c(\"F6489\"), icd10_F64_089 =     c(\"F640\", \"F648\", \"F649\")) )"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_diagnoses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add diagnosis data to skeleton — add_diagnoses","text":"skeleton data.table containing main skeleton structure created create_skeleton dataset data.table containing hospital registry data diagnosis codes. Must columns person ID, admission date (indatum), least one diagnosis code column. Expected diagnosis columns make_lowercase_names(): hdia (main), dia1/dia2/etc (secondary), ekod1/ekod2/etc (external causes), icd7*, icd9* id_name Character string specifying name ID variable dataset diag_type Character string specifying diagnosis types search: \"\" (default) - Search main (hdia), secondary (dia*),     external cause (ekod*), historical ICD version columns (icd7*, icd9*) \"main\" - Search main diagnosis column (hdia) diags Named list ICD code patterns search . Names become variable names skeleton. Patterns include \"^\" prefix (automatically added). Use exclusions \"!\" prefix. Example: list(\"depression\" = c(\"F32\", \"F33\"), \"anxiety\" = c(\"F40\", \"F41\"))","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_diagnoses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add diagnosis data to skeleton — add_diagnoses","text":"skeleton data.table modified reference diagnosis variables added.   New boolean variables created diagnosis pattern, TRUE diagnosis present.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_diagnoses.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add diagnosis data to skeleton — add_diagnoses","text":"function searches across different diagnosis code column types based diag_type parameter: diag_type = \"\": Searches hdia (main diagnosis),     dia1, dia2, ... (secondary diagnoses), ekod1, ekod2, ...     (external cause codes), icd7* (ICD-7 codes), icd9* (ICD-9 codes) diag_type = \"main\": Searches hdia (main diagnosis)","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_diagnoses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add diagnosis data to skeleton — add_diagnoses","text":"","code":"# Load fake data data(\"fake_person_ids\", package = \"swereg\") data(\"fake_inpatient_diagnoses\", package = \"swereg\") swereg::make_lowercase_names(fake_inpatient_diagnoses, date_columns = \"indatum\") #> Found additional date columns not in date_columns: utdatum. Consider adding them for automatic date parsing.  # Create skeleton skeleton <- create_skeleton(fake_person_ids[1:10], \"2020-01-01\", \"2020-12-31\")  # Add diagnoses diag_patterns <- list(   \"depression\" = c(\"F32\", \"F33\"),   \"anxiety\" = c(\"F40\", \"F41\") ) add_diagnoses(skeleton, fake_inpatient_diagnoses, \"lopnr\", \"both\", diag_patterns)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_icdo3s.html","id":null,"dir":"Reference","previous_headings":"","what":"Add ICD-O-3 oncology codes to skeleton — add_icdo3s","title":"Add ICD-O-3 oncology codes to skeleton — add_icdo3s","text":"Searches specific ICD-O-3 (International Classification Diseases Oncology, 3rd edition) codes Swedish cancer registry data adds corresponding boolean variables skeleton. ICD-O-3 used classify malignant neoplasms (cancers) histological type (morphology) anatomical site (topography).","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_icdo3s.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add ICD-O-3 oncology codes to skeleton — add_icdo3s","text":"","code":"add_icdo3s(skeleton, dataset, id_name, icdo3s = list())"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_icdo3s.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add ICD-O-3 oncology codes to skeleton — add_icdo3s","text":"skeleton data.table containing main skeleton structure created create_skeleton dataset data.table containing cancer registry data ICD-O-3 codes. Must columns person ID, date variables, ICD-O-3 code column (icdo3) id_name Character string specifying name ID variable dataset icdo3s Named list ICD-O-3 code patterns search . Names become variable names skeleton. ICD-O-3 codes combine morphology (4 digits + behavior code) topography (C codes). Examples pattern matching: \"^8140\" - Adenocarcinoma, NOS (morphology code) \"^C50\" - Breast cancer (topography code) \"8500/3\" - Infiltrating duct carcinoma (morphology behavior)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_icdo3s.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add ICD-O-3 oncology codes to skeleton — add_icdo3s","text":"skeleton data.table modified reference ICD-O-3 variables added.   New boolean variables created ICD-O-3 pattern, TRUE code present.","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_icdo3s.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add ICD-O-3 oncology codes to skeleton — add_icdo3s","text":"","code":"if (FALSE) { # \\dontrun{ # ICD-O-3 data requires a dataset with an 'icdo3' column # (not included in fake_inpatient_diagnoses) data(\"fake_person_ids\", package = \"swereg\")  # Load your ICD-O-3 cancer registry data cancer_data <- your_cancer_registry_data swereg::make_lowercase_names(cancer_data, date_columns = \"indatum\")  # Create skeleton skeleton <- create_skeleton(fake_person_ids[1:10], \"2020-01-01\", \"2020-12-31\")  # Add ICD-O-3 codes for specific cancer types cancer_codes <- list(   \"adenocarcinoma\" = c(\"^8140\"),   \"breast_cancer\" = c(\"^C50\") ) add_icdo3s(skeleton, cancer_data, \"lopnr\", cancer_codes) } # }"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_onetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Add one-time data to skeleton — add_onetime","title":"Add one-time data to skeleton — add_onetime","text":"Merges one-time data (non-longitudinal) main skeleton data structure. function used adding data change time, demographic information baseline characteristics.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_onetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add one-time data to skeleton — add_onetime","text":"","code":"add_onetime(skeleton, data, id_name)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_onetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add one-time data to skeleton — add_onetime","text":"skeleton data.table containing main skeleton structure id time variables data data.table containing one-time data merged id_name Character string specifying name ID variable data","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_onetime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add one-time data to skeleton — add_onetime","text":"skeleton data.table modified reference one-time data merged .   Columns data already exist skeleton prefixed \".\"","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_onetime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add one-time data to skeleton — add_onetime","text":"","code":"# Load fake data data(\"fake_person_ids\", package = \"swereg\") data(\"fake_demographics\", package = \"swereg\") swereg::make_lowercase_names(fake_demographics) #> Found potential date columns: fodelseman. Consider adding them to date_columns parameter for automatic date parsing.  # Create skeleton skeleton <- create_skeleton(fake_person_ids[1:5], \"2020-01-01\", \"2020-12-31\")  # Add demographic data add_onetime(skeleton, fake_demographics, \"lopnr\") #>         id isoyear isoyearweek is_isoyear isoyearweeksun personyears fodelseman #>      <int>   <int>      <char>     <lgcl>         <Date>       <num>     <char> #>   1:     1    1900     1900-**       TRUE     1900-07-01  1.00000000       2004 #>   2:     1    1901     1901-**       TRUE     1901-06-30  1.00000000       2004 #>   3:     1    1902     1902-**       TRUE     1902-06-29  1.00000000       2004 #>   4:     1    1903     1903-**       TRUE     1903-06-28  1.00000000       2004 #>   5:     1    1904     1904-**       TRUE     1904-07-03  1.00000000       2004 #>  ---                                                                            #> 866:     5    2020     2020-49      FALSE     2020-12-06  0.01913876       1990 #> 867:     5    2020     2020-50      FALSE     2020-12-13  0.01913876       1990 #> 868:     5    2020     2020-51      FALSE     2020-12-20  0.01913876       1990 #> 869:     5    2020     2020-52      FALSE     2020-12-27  0.01913876       1990 #> 870:     5    2020     2020-53      FALSE     2021-01-03  0.01913876       1990 #>      doddatum #>        <char> #>   1:     2008 #>   2:     2008 #>   3:     2008 #>   4:     2008 #>   5:     2008 #>  ---          #> 866:          #> 867:          #> 868:          #> 869:          #> 870:           # Check added variables names(skeleton) #> [1] \"id\"             \"isoyear\"        \"isoyearweek\"    \"is_isoyear\"     #> [5] \"isoyearweeksun\" \"personyears\"    \"fodelseman\"     \"doddatum\""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_operations.html","id":null,"dir":"Reference","previous_headings":"","what":"Add surgical operation data to skeleton — add_operations","title":"Add surgical operation data to skeleton — add_operations","text":"Searches specific surgical operation codes Swedish hospital registry data adds corresponding boolean variables skeleton. Includes predefined operation codes relevant gender-affirming procedures.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_operations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add surgical operation data to skeleton — add_operations","text":"","code":"add_operations(   skeleton,   dataset,   id_name,   ops = list(op_afab_mastectomy = c(\"HAC10\", \"HAC20\", \"HAC99\", \"HAC15\"),     op_afab_breast_reconst_and_other_breast_ops = c(\"HAD20\", \"HAD30\", \"HAD35\", \"HAD99\",     \"HAE99\"), op_afab_penis_test_prosth = c(\"KFH50\", \"KGV30\", \"KGW96\", \"KGH96\"),     op_afab_internal_genital = c(\"LCD00\", \"LCD01\", \"LCD04\", \"LCD10\", \"LCD11\", \"LCD96\",     \"LCD97\"), op_afab_colpectomy = c(\"LED00\"),     op_amab_breast_reconst_and_other_breast_ops = c(\"HAD00\", \"HAD10\", \"HAD99\", \"HAE00\",     \"HAE20\", \"HAE99\"), op_amab_reconst_vag = c(\"LEE10\", \"LEE40\", \"LEE96\",       \"LFE10\",     \"LFE96\"), op_amab_penis_amp = c(\"KGC10\"), op_amab_larynx = c(\"DQD40\")) )"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_operations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add surgical operation data to skeleton — add_operations","text":"skeleton data.table containing main skeleton structure created create_skeleton dataset data.table containing hospital registry data operation codes. Must columns person ID, date variables, operation codes (op1, op2, etc.) id_name Character string specifying name ID variable dataset ops Named list operation code patterns search . Names become variable names skeleton. Default includes comprehensive gender-affirming surgery codes: Mastectomy procedures (HAC10, HAC20, etc.) Breast reconstruction (HAD20, HAD30, etc.) Genital operations (various KFH, KGV, LCD, LED, LEE codes) Larynx operations (DQD40)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_operations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add surgical operation data to skeleton — add_operations","text":"skeleton data.table modified reference operation variables added.   New boolean variables created operation pattern, TRUE operation present.","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_operations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add surgical operation data to skeleton — add_operations","text":"","code":"# Load fake data data(\"fake_person_ids\", package = \"swereg\") data(\"fake_inpatient_diagnoses\", package = \"swereg\") swereg::make_lowercase_names(fake_inpatient_diagnoses, date_columns = \"indatum\") #> Found additional date columns not in date_columns: utdatum. Consider adding them for automatic date parsing.  # Create skeleton skeleton <- create_skeleton(fake_person_ids[1:10], \"2020-01-01\", \"2020-12-31\")  # Add operations (using default gender-affirming surgery codes) add_operations(skeleton, fake_inpatient_diagnoses, \"lopnr\")  # Or specify custom operation codes custom_ops <- list(\"mastectomy\" = c(\"HAC10\", \"HAC20\")) add_operations(skeleton, fake_inpatient_diagnoses, \"lopnr\", custom_ops)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_rx.html","id":null,"dir":"Reference","previous_headings":"","what":"Add prescription drug data to skeleton — add_rx","title":"Add prescription drug data to skeleton — add_rx","text":"Searches specific drug codes (ATC product names) Swedish prescription registry data adds corresponding boolean variables skeleton based prescription periods duration treatment.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_rx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add prescription drug data to skeleton — add_rx","text":"","code":"add_rx(   skeleton,   lmed,   id_name = \"lopnr\",   rxs = list(rx_hormones_pubblock = c(\"L02AE\", \"H01CA\")),   source = \"atc\" )"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_rx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add prescription drug data to skeleton — add_rx","text":"skeleton data.table containing main skeleton structure created create_skeleton lmed data.table containing prescription registry data (LMED). Must columns person ID, prescription date (edatum), treatment duration (fddd), drug codes (atc) product names (produkt) id_name Character string specifying name ID variable (default: \"lopnr\") rxs Named list drug code patterns search . Names become variable names skeleton. Patterns include \"^\" prefix (automatically added). Default includes hormone therapy codes puberty blockers (L02AE, H01CA). Common patterns include: Antidepressants: \"N06A\" Hormone therapy: \"G03\", \"L02AE\", \"H01CA\" Cardiovascular drugs: \"C07\", \"C08\", \"C09\" source Character string specifying search field: \"atc\" (default) - Search ATC codes \"produkt\" - Search product names","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_rx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add prescription drug data to skeleton — add_rx","text":"skeleton data.table modified reference prescription variables added.   Variables TRUE periods prescription active based start/stop dates   calculated prescription date + treatment duration","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_rx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add prescription drug data to skeleton — add_rx","text":"","code":"# Load fake data data(\"fake_person_ids\", package = \"swereg\") data(\"fake_prescriptions\", package = \"swereg\") swereg::make_lowercase_names(fake_prescriptions, date_columns = \"edatum\")  # Create skeleton skeleton <- create_skeleton(fake_person_ids[1:10], \"2020-01-01\", \"2020-12-31\")  # Add prescription data rx_patterns <- list(   \"antidepressants\" = c(\"N06A\"),   \"hormones\" = c(\"G03\", \"L02AE\") ) add_rx(skeleton, fake_prescriptions, \"p444_lopnr_personnr\", rx_patterns, \"atc\") #> 2025-12-24 07:39:04.558092 antidepressants #> 2025-12-24 07:39:04.632555 hormones"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_snomed3s.html","id":null,"dir":"Reference","previous_headings":"","what":"Add SNOMED-CT version 3 codes to skeleton — add_snomed3s","title":"Add SNOMED-CT version 3 codes to skeleton — add_snomed3s","text":"Searches specific SNOMED-CT (Systematized Nomenclature Medicine - Clinical Terms) version 3 codes Swedish hospital registry data adds corresponding boolean variables skeleton. SNOMED-CT v3 provides standardized clinical terminology procedures, findings, diagnoses used Swedish healthcare records.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_snomed3s.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add SNOMED-CT version 3 codes to skeleton — add_snomed3s","text":"","code":"add_snomed3s(skeleton, dataset, id_name, snomed3s = list())"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_snomed3s.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add SNOMED-CT version 3 codes to skeleton — add_snomed3s","text":"skeleton data.table containing main skeleton structure created create_skeleton dataset data.table containing hospital registry data SNOMED-CT v3 codes. Must columns person ID, date variables, SNOMED-CT v3 code column (snomed3) id_name Character string specifying name ID variable dataset snomed3s Named list SNOMED-CT v3 code patterns search . Names become variable names skeleton. SNOMED-CT codes hierarchical can matched using pattern matching. Examples pattern matching: \"^80146002\" - Appendectomy procedure \"^44054006\" - Diabetes mellitus type 2 Use regex patterns match code families hierarchies","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_snomed3s.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add SNOMED-CT version 3 codes to skeleton — add_snomed3s","text":"skeleton data.table modified reference SNOMED-CT v3 variables added.   New boolean variables created SNOMED-CT pattern, TRUE code present.","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_snomed3s.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add SNOMED-CT version 3 codes to skeleton — add_snomed3s","text":"","code":"if (FALSE) { # \\dontrun{ # SNOMED-CT v3 data requires a dataset with a 'snomed3' column # (not included in fake_inpatient_diagnoses) data(\"fake_person_ids\", package = \"swereg\")  # Load your SNOMED-CT v3 registry data snomed_data <- your_snomed_registry_data swereg::make_lowercase_names(snomed_data, date_columns = \"indatum\")  # Create skeleton skeleton <- create_skeleton(fake_person_ids[1:10], \"2020-01-01\", \"2020-12-31\")  # Add SNOMED-CT v3 codes for specific clinical concepts snomed_codes <- list(   \"appendectomy\" = c(\"^80146002\"),   \"diabetes_t2\" = c(\"^44054006\") ) add_snomed3s(skeleton, snomed_data, \"lopnr\", snomed_codes) } # }"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_snomedo10s.html","id":null,"dir":"Reference","previous_headings":"","what":"Add SNOMED-CT version 10 codes to skeleton — add_snomedo10s","title":"Add SNOMED-CT version 10 codes to skeleton — add_snomedo10s","text":"Searches specific SNOMED-CT (Systematized Nomenclature Medicine - Clinical Terms) version 10 codes Swedish hospital registry data adds corresponding boolean variables skeleton. SNOMED-CT v10 provides standardized clinical terminology procedures, findings, diagnoses used Swedish healthcare records.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_snomedo10s.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add SNOMED-CT version 10 codes to skeleton — add_snomedo10s","text":"","code":"add_snomedo10s(skeleton, dataset, id_name, snomedo10s = list())"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_snomedo10s.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add SNOMED-CT version 10 codes to skeleton — add_snomedo10s","text":"skeleton data.table containing main skeleton structure created create_skeleton dataset data.table containing hospital registry data SNOMED-CT v10 codes. Must columns person ID, date variables, SNOMED-CT v10 code column (snomedo10) id_name Character string specifying name ID variable dataset snomedo10s Named list SNOMED-CT v10 code patterns search . Names become variable names skeleton. SNOMED-CT codes hierarchical can matched using pattern matching. Examples pattern matching: \"^80146002\" - Appendectomy procedure \"^44054006\" - Diabetes mellitus type 2 Use regex patterns match code families hierarchies","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_snomedo10s.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add SNOMED-CT version 10 codes to skeleton — add_snomedo10s","text":"skeleton data.table modified reference SNOMED-CT v10 variables added.   New boolean variables created SNOMED-CT pattern, TRUE code present.","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/add_snomedo10s.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add SNOMED-CT version 10 codes to skeleton — add_snomedo10s","text":"","code":"if (FALSE) { # \\dontrun{ # SNOMED-CT v10 data requires a dataset with a 'snomedo10' column # (not included in fake_inpatient_diagnoses) data(\"fake_person_ids\", package = \"swereg\")  # Load your SNOMED-CT v10 registry data snomed_data <- your_snomed_registry_data swereg::make_lowercase_names(snomed_data, date_columns = \"indatum\")  # Create skeleton skeleton <- create_skeleton(fake_person_ids[1:10], \"2020-01-01\", \"2020-12-31\")  # Add SNOMED-CT v10 codes for specific clinical concepts snomed_codes <- list(   \"appendectomy\" = c(\"^80146002\"),   \"diabetes_t2\" = c(\"^44054006\") ) add_snomedo10s(skeleton, snomed_data, \"lopnr\", snomed_codes) } # }"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/as_logical_max_with_infinite_as_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert maximum to logical while treating infinite values as NA — as_logical_max_with_infinite_as_na","title":"Convert maximum to logical while treating infinite values as NA — as_logical_max_with_infinite_as_na","text":"Computes maximum value converts logical, treating infinite values NA. Useful aggregating boolean data.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/as_logical_max_with_infinite_as_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert maximum to logical while treating infinite values as NA — as_logical_max_with_infinite_as_na","text":"","code":"as_logical_max_with_infinite_as_na(x, na.rm = T)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/as_logical_max_with_infinite_as_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert maximum to logical while treating infinite values as NA — as_logical_max_with_infinite_as_na","text":"x Numeric vector na.rm Logical, whether remove NA values calculation (default: TRUE)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/as_logical_max_with_infinite_as_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert maximum to logical while treating infinite values as NA — as_logical_max_with_infinite_as_na","text":"Logical value (maximum converted logical) infinite values NA","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/as_logical_min_with_infinite_as_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert minimum to logical while treating infinite values as NA — as_logical_min_with_infinite_as_na","title":"Convert minimum to logical while treating infinite values as NA — as_logical_min_with_infinite_as_na","text":"Computes minimum value converts logical, treating infinite values NA. Useful aggregating boolean data.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/as_logical_min_with_infinite_as_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert minimum to logical while treating infinite values as NA — as_logical_min_with_infinite_as_na","text":"","code":"as_logical_min_with_infinite_as_na(x, na.rm = T)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/as_logical_min_with_infinite_as_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert minimum to logical while treating infinite values as NA — as_logical_min_with_infinite_as_na","text":"x Numeric vector na.rm Logical, whether remove NA values calculation (default: TRUE)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/as_logical_min_with_infinite_as_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert minimum to logical while treating infinite values as NA — as_logical_min_with_infinite_as_na","text":"Logical value (minimum converted logical) infinite values NA","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/create_skeleton.html","id":null,"dir":"Reference","previous_headings":"","what":"Create longitudinal data skeleton — create_skeleton","title":"Create longitudinal data skeleton — create_skeleton","text":"Creates longitudinal data skeleton individual IDs time periods (ISO years ISO year-weeks) Swedish registry data analysis. skeleton provides framework merging various registry datasets consistent time structure.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/create_skeleton.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create longitudinal data skeleton — create_skeleton","text":"","code":"create_skeleton(ids, date_min, date_max)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/create_skeleton.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create longitudinal data skeleton — create_skeleton","text":"ids Vector individual IDs include skeleton date_min Date object specifying start date analysis period date_max Date object specifying end date analysis period","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/create_skeleton.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create longitudinal data skeleton — create_skeleton","text":"data.table skeleton columns: id: Individual identifier isoyear: ISO year (integer) isoyearweek: ISO year-week (character, format \"YYYY-WW\" \"YYYY-**\" annual rows) is_isoyear: Logical indicating row represents annual (TRUE) weekly (FALSE) data isoyearweeksun: Date representing Sunday (last day) ISO week/year personyears: Person-time contribution (1 annual rows, 1/52.25 weekly rows)","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/create_skeleton.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create longitudinal data skeleton — create_skeleton","text":"","code":"# Load fake data data(\"fake_person_ids\", package = \"swereg\")  # Create skeleton for 2020-2022 period skeleton <- create_skeleton(   ids = fake_person_ids[1:10],   date_min = as.Date(\"2020-01-01\"),   date_max = as.Date(\"2022-12-31\") ) utils::head(skeleton) #>       id isoyear isoyearweek is_isoyear isoyearweeksun personyears #>    <int>   <int>      <char>     <lgcl>         <Date>       <num> #> 1:     1    1900     1900-**       TRUE     1900-07-01           1 #> 2:     1    1901     1901-**       TRUE     1901-06-30           1 #> 3:     1    1902     1902-**       TRUE     1902-06-29           1 #> 4:     1    1903     1903-**       TRUE     1903-06-28           1 #> 5:     1    1904     1904-**       TRUE     1904-07-03           1 #> 6:     1    1905     1905-**       TRUE     1905-07-02           1  # Check structure utils::str(skeleton) #> Classes ‘data.table’ and 'data.frame':\t2780 obs. of  6 variables: #>  $ id            : int  1 1 1 1 1 1 1 1 1 1 ... #>  $ isoyear       : int  1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 ... #>  $ isoyearweek   : chr  \"1900-**\" \"1901-**\" \"1902-**\" \"1903-**\" ... #>  $ is_isoyear    : logi  TRUE TRUE TRUE TRUE TRUE TRUE ... #>  $ isoyearweeksun: Date, format: \"1900-07-01\" \"1901-06-30\" ... #>  $ personyears   : num  1 1 1 1 1 1 1 1 1 1 ... #>  - attr(*, \".internal.selfref\")=<externalptr>"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Fake Swedish Registry Datasets — fake_data","title":"Fake Swedish Registry Datasets — fake_data","text":"datasets contain synthetic Swedish healthcare registry data development, testing, vignettes. mimic structure format real Swedish healthcare registries contain completely fabricated data.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fake Swedish Registry Datasets — fake_data","text":"","code":"fake_person_ids  fake_demographics  fake_annual_family  fake_inpatient_diagnoses  fake_outpatient_diagnoses  fake_prescriptions  fake_cod"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Fake Swedish Registry Datasets — fake_data","text":"Various data structures matching real Swedish registries: object class integer length 1000. object class data.table (inherits data.frame) 1000 rows 3 columns. object class data.table (inherits data.frame) 1000 rows 2 columns. object class data.table (inherits data.frame) 3000 rows 45 columns. object class data.table (inherits data.frame) 2000 rows 41 columns. object class data.table (inherits data.frame) 8000 rows 37 columns. object class data.table (inherits data.frame) 50 rows 5 columns.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Fake Swedish Registry Datasets — fake_data","text":"Generated synthetic data based real Swedish healthcare registry structures","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fake Swedish Registry Datasets — fake_data","text":"datasets created dev/generate_fake_data.R contain: Key features: Personal identifiers numeric (e.g., 623334, 753064) Prescription data uses column name \"p444_lopnr_personnr\" ICD-10 codes include gender dysphoria (F64*), mental health (F20*, F32*, F40*), physical health codes ATC codes include hormone therapy (G03*), mental health medications (N05*, N06*) Date ranges span 1978-2021 depending registry Realistic missing data patterns Usage requirements: Always apply swereg::make_lowercase_names() loading data Use appropriate identifier column names (lopnr vs p444_lopnr_personnr) Follow Swedish registry conventions date formats","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":"fake-person-ids","dir":"Reference","previous_headings":"","what":"fake_person_ids","title":"Fake Swedish Registry Datasets — fake_data","text":"numeric vector 1000 fake personal identifiers (lopnr). Used reference IDs across datasets.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":"fake-demographics","dir":"Reference","previous_headings":"","what":"fake_demographics","title":"Fake Swedish Registry Datasets — fake_data","text":"Demographics data (SCB format) 1000 records: lopnr Personal identifier matching fake_person_ids fodelseman Birth year-month (YYYYMM format) DodDatum Death date (YYYYMMDD format) empty string","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":"fake-annual-family","dir":"Reference","previous_headings":"","what":"fake_annual_family","title":"Fake Swedish Registry Datasets — fake_data","text":"Annual family status data (SCB format) 1000 records: LopNr Personal identifier (mixed case real data) FamTyp Family type code (2-digit character)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":"fake-inpatient-diagnoses","dir":"Reference","previous_headings":"","what":"fake_inpatient_diagnoses","title":"Fake Swedish Registry Datasets — fake_data","text":"Inpatient hospital diagnoses (NPR format) ~3000 records: LopNr Personal identifier AR Year care INDATUMA Admission date (YYYYMMDD character) INDATUM Admission date (Date class) UTDATUMA Discharge date (YYYYMMDD character) UTDATUM Discharge date (Date class) HDIA Main diagnosis (ICD-10 code) DIA1-DIA30 Additional diagnoses EKOD1-EKOD7 External cause codes OP Operation codes","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":"fake-outpatient-diagnoses","dir":"Reference","previous_headings":"","what":"fake_outpatient_diagnoses","title":"Fake Swedish Registry Datasets — fake_data","text":"Outpatient specialist diagnoses (NPR format) ~2000 records. structure inpatient data without discharge dates.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":"fake-prescriptions","dir":"Reference","previous_headings":"","what":"fake_prescriptions","title":"Fake Swedish Registry Datasets — fake_data","text":"Prescription drug dispensing data (LMED format) ~8000 records: p444_lopnr_personnr Personal identifier p444 prefix Fall Case indicator Kontroll Control indicator VARUNR Product number ATC ATC classification code ALDER Age prescription LK Healthcare county code EDATUM End date FDATUM Start date OTYP Origin type ... Additional 27 columns matching real LMED structure","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":"fake-cod","dir":"Reference","previous_headings":"","what":"fake_cod","title":"Fake Swedish Registry Datasets — fake_data","text":"Cause death data ~50 records (Swedish registry format): lopnr Personal identifier dodsdat Date death ulorsak Underlying cause death (ICD-10) - Swedish variable name morsak1 First multiple/contributory cause death morsak2 Second multiple/contributory cause death","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/fake_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fake Swedish Registry Datasets — fake_data","text":"","code":"if (FALSE) { # \\dontrun{ # Load fake data data(\"fake_person_ids\") data(\"fake_demographics\") data(\"fake_prescriptions\")  # CRITICAL: Apply lowercase names swereg::make_lowercase_names(fake_demographics) swereg::make_lowercase_names(fake_prescriptions)  # Create skeleton with fake data skeleton <- create_skeleton(   ids = fake_person_ids[1:100],   date_min = \"2015-01-01\",   date_max = \"2020-12-31\" )  # Add demographics add_onetime(skeleton, fake_demographics[lopnr %in% fake_person_ids[1:100]],              id_name = \"lopnr\") } # }"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/first_non_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Get first non-NA value from vector — first_non_na","title":"Get first non-NA value from vector — first_non_na","text":"Returns first non-missing value vector, useful data cleaning summarization tasks.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/first_non_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get first non-NA value from vector — first_non_na","text":"","code":"first_non_na(x)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/first_non_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get first non-NA value from vector — first_non_na","text":"x Vector type","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/first_non_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get first non-NA value from vector — first_non_na","text":"First non-NA value vector","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/first_non_na.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get first non-NA value from vector — first_non_na","text":"","code":"x <- c(NA, NA, 3, 4, 5) first_non_na(x)  # Returns 3 #> [1] 3 #> attr(,\"na.action\") #> [1] 1 2 #> attr(,\"class\") #> [1] \"omit\""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/last_non_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Get last non-NA value from vector — last_non_na","title":"Get last non-NA value from vector — last_non_na","text":"Returns last non-missing value vector, useful data cleaning summarization tasks.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/last_non_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get last non-NA value from vector — last_non_na","text":"","code":"last_non_na(x)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/last_non_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get last non-NA value from vector — last_non_na","text":"x Vector type","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/last_non_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get last non-NA value from vector — last_non_na","text":"Last non-NA value vector","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/last_non_na.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get last non-NA value from vector — last_non_na","text":"","code":"x <- c(1, 2, 3, NA, NA) last_non_na(x)  # Returns 3 #> [1] 3 #> attr(,\"na.action\") #> [1] 4 5 #> attr(,\"class\") #> [1] \"omit\""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/make_lowercase_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert column names to lowercase and optionally clean date columns — make_lowercase_names","title":"Convert column names to lowercase and optionally clean date columns — make_lowercase_names","text":"Generic function convert column names object lowercase. Optionally parses cleans specified date columns using Swedish registry date format handling. Methods provided data.table default objects.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/make_lowercase_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert column names to lowercase and optionally clean date columns — make_lowercase_names","text":"","code":"make_lowercase_names(x, date_columns = NULL, ...)  # Default S3 method make_lowercase_names(x, date_columns = NULL, ...)  # S3 method for class 'data.table' make_lowercase_names(x, date_columns = NULL, ...)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/make_lowercase_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert column names to lowercase and optionally clean date columns — make_lowercase_names","text":"x object named columns (data.frame, data.table, etc.) date_columns Character vector specifying names date columns clean. use lowercase names since column names converted lowercase first. uppercase names provided, warning issued lowercase versions used. provided, columns parsed using Swedish date format handling converted Date class place (keeping original column names). NULL, function suggest commonly found Swedish registry date columns. ... Additional arguments date parsing (default_month_day, default_day, na_strings)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/make_lowercase_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert column names to lowercase and optionally clean date columns — make_lowercase_names","text":"object column names converted lowercase, optionally   cleaned date columns date_columns specified (converted Date class place)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/make_lowercase_names.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert column names to lowercase and optionally clean date columns — make_lowercase_names","text":"function automatically detects common Swedish registry date columns (indatum, utdatum, edatum, dodsdat, fodelseman) provides helpful messages suggesting inclusion date_columns parameter.","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/make_lowercase_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert column names to lowercase and optionally clean date columns — make_lowercase_names","text":"","code":"# Load fake data data(\"fake_demographics\", package = \"swereg\")  # Basic usage - convert column names to lowercase # This will show a message suggesting to include 'fodelseman' in date_columns swereg::make_lowercase_names(fake_demographics) #> Found potential date columns: fodelseman. Consider adding them to date_columns parameter for automatic date parsing.  # With date cleaning - clean birth dates (use lowercase column names) swereg::make_lowercase_names(fake_demographics, date_columns = \"fodelseman\")  # Check that fodelseman column was converted to Date class head(fake_demographics$fodelseman) #> [1] \"2004-07-01\" \"1955-07-01\" \"1954-07-01\" \"1974-07-01\" \"1990-07-01\" #> [6] \"1984-07-01\"  # For diagnosis data with multiple date columns (use lowercase column names) data(\"fake_inpatient_diagnoses\", package = \"swereg\") swereg::make_lowercase_names(fake_inpatient_diagnoses, date_columns = c(\"indatum\", \"utdatum\"))  # The function suggests missing date columns swereg::make_lowercase_names(fake_inpatient_diagnoses, date_columns = \"indatum\") #> Found additional date columns not in date_columns: utdatum. Consider adding them for automatic date parsing. # Message: \"Found additional date columns not in date_columns: utdatum\""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/make_rowind_first_occurrence.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform rowdep variable to rowind variable using first occurrence — make_rowind_first_occurrence","title":"Transform rowdep variable to rowind variable using first occurrence — make_rowind_first_occurrence","text":"Creates row-independent (rowind) variable finding first occurrence condition TRUE extracting corresponding value. common pattern longitudinal registry data analysis creating stable person-level characteristics.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/make_rowind_first_occurrence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform rowdep variable to rowind variable using first occurrence — make_rowind_first_occurrence","text":"","code":"make_rowind_first_occurrence(dt, condition, value_var, new_var)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/make_rowind_first_occurrence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform rowdep variable to rowind variable using first occurrence — make_rowind_first_occurrence","text":"dt data.table longitudinal data condition Character string representing logical condition evaluate value_var Character string naming column extract values new_var Character string naming new rowind variable create","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/make_rowind_first_occurrence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform rowdep variable to rowind variable using first occurrence — make_rowind_first_occurrence","text":"data.table modified reference (invisibly returned)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/make_rowind_first_occurrence.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transform rowdep variable to rowind variable using first occurrence — make_rowind_first_occurrence","text":"function implements common pattern transforming time-varying (rowdep) variables time-invariant (rowind) variables capturing value first occurrence condition. transformation follows steps: 1. Create temporary variable condition TRUE 2. Use first_non_na() find first occurrence person 3. Clean temporary variables automatically equivalent manual pattern: dt[condition, temp := value_var] dt[, new_var := first_non_na(temp), = .(id)] dt[, temp := NULL]","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/reference/make_rowind_first_occurrence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform rowdep variable to rowind variable using first occurrence — make_rowind_first_occurrence","text":"","code":"if (FALSE) { # \\dontrun{ # Create example skeleton with diagnosis data skeleton <- create_skeleton(c(1,2,3), \"2020-01-01\", \"2020-12-31\")  # Add some example diagnosis data add_diagnoses(skeleton, diagnosis_data, \"lopnr\",               diags = list(\"example_diag\" = \"^F64\"))  # Transform: Age at first example diagnosis make_rowind_first_occurrence(skeleton,                              condition = \"diag_example_diag == TRUE\",                              value_var = \"age\",                              new_var = \"rowind_age_first_example_diag\") } # }"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/max_with_infinite_as_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate maximum while treating infinite values as NA — max_with_infinite_as_na","title":"Calculate maximum while treating infinite values as NA — max_with_infinite_as_na","text":"Computes maximum value numeric vector, converting infinite values NA. Useful robust statistical calculations.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/max_with_infinite_as_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate maximum while treating infinite values as NA — max_with_infinite_as_na","text":"","code":"max_with_infinite_as_na(x, na.rm = T)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/max_with_infinite_as_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate maximum while treating infinite values as NA — max_with_infinite_as_na","text":"x Numeric vector na.rm Logical, whether remove NA values calculation (default: TRUE)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/max_with_infinite_as_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate maximum while treating infinite values as NA — max_with_infinite_as_na","text":"Maximum value infinite values converted NA","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/max_with_infinite_as_na.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate maximum while treating infinite values as NA — max_with_infinite_as_na","text":"","code":"x <- c(1, 2, 4) max_with_infinite_as_na(x)  # Returns 4 #> [1] 4  y <- c(1, 2, Inf, 4, -Inf) max_with_infinite_as_na(y)  # Returns NA (because of infinite values) #> [1] NA"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/min_with_infinite_as_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate minimum while treating infinite values as NA — min_with_infinite_as_na","title":"Calculate minimum while treating infinite values as NA — min_with_infinite_as_na","text":"Computes minimum value numeric vector, converting infinite values NA. Useful robust statistical calculations.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/min_with_infinite_as_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate minimum while treating infinite values as NA — min_with_infinite_as_na","text":"","code":"min_with_infinite_as_na(x, na.rm = T)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/min_with_infinite_as_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate minimum while treating infinite values as NA — min_with_infinite_as_na","text":"x Numeric vector na.rm Logical, whether remove NA values calculation (default: TRUE)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/min_with_infinite_as_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate minimum while treating infinite values as NA — min_with_infinite_as_na","text":"Minimum value infinite values converted NA","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/min_with_infinite_as_na.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate minimum while treating infinite values as NA — min_with_infinite_as_na","text":"","code":"x <- c(1, 2, 4) min_with_infinite_as_na(x)  # Returns 1 #> [1] 1  y <- c(1, 2, Inf, 4, -Inf) min_with_infinite_as_na(y)  # Returns NA (because of infinite values) #> [1] NA"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/parse_swedish_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse Swedish registry dates — parse_swedish_date","title":"Parse Swedish registry dates — parse_swedish_date","text":"Parses Swedish registry dates may varying precision (year , year-month, full date) converts proper Date objects. Handles common Swedish registry date formats missing date patterns.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/parse_swedish_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse Swedish registry dates — parse_swedish_date","text":"","code":"parse_swedish_date(   date_string,   default_month_day = \"0701\",   default_day = \"15\",   na_strings = c(\"\", \"NA\", \"9999\", \"99999999\") )"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/parse_swedish_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse Swedish registry dates — parse_swedish_date","text":"date_string Character vector dates Swedish registry format default_month_day Character string default month-day year provided (default: \"0701\" July 1st) default_day Character string default day year-month provided (default: \"15\" 15th) na_strings Character vector strings treat NA (default: c(\"\", \"NA\", \"9999\", \"99999999\"))","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/parse_swedish_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse Swedish registry dates — parse_swedish_date","text":"Date vector parsed dates","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/parse_swedish_date.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse Swedish registry dates — parse_swedish_date","text":"Swedish registry dates often come different formats: 4 characters (YYYY): year known - adds default_month_day 6 characters (YYYYMM): Year month known - adds default_day 8 characters (YYYYMMDD): Full date known - uses -Special handling: \"0000\" endings replaced default_month_day \"00\" endings replaced default_day Invalid dates return NA warnings","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/parse_swedish_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse Swedish registry dates — parse_swedish_date","text":"","code":"# Different date formats dates <- c(\"2020\", \"202003\", \"20200315\", \"19990000\", \"199900\", \"19990600\", \"1989-01-01\", \"\") parse_swedish_date(dates) #> [1] \"2020-07-01\" \"2020-03-15\" \"2020-03-15\" \"1999-07-01\" \"1999-07-01\" #> [6] \"1999-06-15\" \"1989-01-01\" NA            # Custom defaults parse_swedish_date(dates, default_month_day = \"0101\", default_day = \"01\") #> [1] \"2020-01-01\" \"2020-03-01\" \"2020-03-15\" \"1999-01-01\" \"1999-01-01\" #> [6] \"1999-06-01\" \"1989-01-01\" NA"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/steps_to_first.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate steps until first TRUE in a forward window — steps_to_first","title":"Calculate steps until first TRUE in a forward window — steps_to_first","text":"Calculate steps first TRUE forward window","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/steps_to_first.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate steps until first TRUE in a forward window — steps_to_first","text":"","code":"steps_to_first(x, window = 103L)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/steps_to_first.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate steps until first TRUE in a forward window — steps_to_first","text":"x Logical vector window Forward window size (default 103)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/steps_to_first.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate steps until first TRUE in a forward window — steps_to_first","text":"Integer vector steps first TRUE, NA none window","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_data_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate data structure for add_* functions — validate_data_structure","title":"Validate data structure for add_* functions — validate_data_structure","text":"Validate data structure add_* functions","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_data_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate data structure for add_* functions — validate_data_structure","text":"","code":"validate_data_structure(data, required_cols = NULL, data_type = \"data\")"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_data_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate data structure for add_* functions — validate_data_structure","text":"data data.table containing data required_cols Character vector required column names data_type Character string describing data type (error messages)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_data_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate data structure for add_* functions — validate_data_structure","text":"Nothing valid, stops error invalid","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_date_column.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate date column exists and is proper format — validate_date_column","title":"Validate date column exists and is proper format — validate_date_column","text":"Validate date column exists proper format","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_date_column.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate date column exists and is proper format — validate_date_column","text":"","code":"validate_date_column(data, date_col, data_type = \"data\")"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_date_column.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate date column exists and is proper format — validate_date_column","text":"data data.table containing data date_col Character string date column name data_type Character string describing data type (error messages)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_date_column.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate date column exists and is proper format — validate_date_column","text":"Nothing valid, stops error invalid","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_date_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate date columns exist and are proper format — validate_date_columns","title":"Validate date columns exist and are proper format — validate_date_columns","text":"Validate date columns exist proper format","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_date_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate date columns exist and are proper format — validate_date_columns","text":"","code":"validate_date_columns(data, expected_date_cols, data_type = \"data\")"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_date_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate date columns exist and are proper format — validate_date_columns","text":"data data.table containing data expected_date_cols Character vector expected date column names data_type Character string describing data type (error messages)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_date_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate date columns exist and are proper format — validate_date_columns","text":"Nothing valid, stops error invalid","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_death_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate death registry data columns — validate_death_data","title":"Validate death registry data columns — validate_death_data","text":"Validate death registry data columns","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_death_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate death registry data columns — validate_death_data","text":"","code":"validate_death_data(data)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_death_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate death registry data columns — validate_death_data","text":"data data.table containing death registry data","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_death_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate death registry data columns — validate_death_data","text":"Nothing valid, stops error invalid","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_id_column.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate ID column exists in dataset — validate_id_column","title":"Validate ID column exists in dataset — validate_id_column","text":"Validate ID column exists dataset","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_id_column.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate ID column exists in dataset — validate_id_column","text":"","code":"validate_id_column(data, id_name)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_id_column.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate ID column exists in dataset — validate_id_column","text":"data data.table containing data id_name Character string ID column name","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_id_column.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate ID column exists in dataset — validate_id_column","text":"Nothing valid, stops error invalid","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_isoyear.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate isoyear parameter — validate_isoyear","title":"Validate isoyear parameter — validate_isoyear","text":"Validate isoyear parameter","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_isoyear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate isoyear parameter — validate_isoyear","text":"","code":"validate_isoyear(isoyear)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_isoyear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate isoyear parameter — validate_isoyear","text":"isoyear Integer year value","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_isoyear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate isoyear parameter — validate_isoyear","text":"Nothing valid, stops error invalid","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_pattern_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate pattern list for diagnoses/operations/prescriptions/cods — validate_pattern_list","title":"Validate pattern list for diagnoses/operations/prescriptions/cods — validate_pattern_list","text":"Validate pattern list diagnoses/operations/prescriptions/cods","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_pattern_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate pattern list for diagnoses/operations/prescriptions/cods — validate_pattern_list","text":"","code":"validate_pattern_list(pattern_list, pattern_type = \"patterns\")"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_pattern_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate pattern list for diagnoses/operations/prescriptions/cods — validate_pattern_list","text":"pattern_list Named list patterns pattern_type Character string describing pattern type (error messages)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_pattern_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate pattern list for diagnoses/operations/prescriptions/cods — validate_pattern_list","text":"Nothing valid, stops error invalid","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_prescription_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate prescription-specific columns — validate_prescription_data","title":"Validate prescription-specific columns — validate_prescription_data","text":"Validate prescription-specific columns","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_prescription_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate prescription-specific columns — validate_prescription_data","text":"","code":"validate_prescription_data(data)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_prescription_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate prescription-specific columns — validate_prescription_data","text":"data data.table containing prescription data","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_prescription_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate prescription-specific columns — validate_prescription_data","text":"Nothing valid, stops error invalid","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_skeleton_structure.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate skeleton structure — validate_skeleton_structure","title":"Validate skeleton structure — validate_skeleton_structure","text":"Validate skeleton structure","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_skeleton_structure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate skeleton structure — validate_skeleton_structure","text":"","code":"validate_skeleton_structure(skeleton)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_skeleton_structure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate skeleton structure — validate_skeleton_structure","text":"skeleton data.table valid skeleton","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/validate_skeleton_structure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate skeleton structure — validate_skeleton_structure","text":"Nothing valid, stops error invalid","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/x2023_mht_add_lmed.html","id":null,"dir":"Reference","previous_headings":"","what":"Add 2023 MHT-specific prescription data to skeleton — x2023_mht_add_lmed","title":"Add 2023 MHT-specific prescription data to skeleton — x2023_mht_add_lmed","text":"Processes Swedish prescription registry data (LMED) specifically 2023 Menopausal Hormone Therapy (MHT) study. Categorizes medications predefined groups, applies duration fixes, creates treatment approach variables.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/x2023_mht_add_lmed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add 2023 MHT-specific prescription data to skeleton — x2023_mht_add_lmed","text":"","code":"x2023_mht_add_lmed(skeleton, lmed)"},{"path":"https://papadopoulos-lab.github.io/swereg/reference/x2023_mht_add_lmed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add 2023 MHT-specific prescription data to skeleton — x2023_mht_add_lmed","text":"skeleton data.table containing main skeleton structure lmed data.table containing prescription registry data columns: p1163_lopnr_personnr (ID), produkt (product name), edatum (dispensing date), fddd (duration days), atc (ATC code)","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/x2023_mht_add_lmed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add 2023 MHT-specific prescription data to skeleton — x2023_mht_add_lmed","text":"skeleton data.table modified reference MHT treatment   variables approach categorizations added. Returns modified skeleton invisibly.","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/x2023_mht_add_lmed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add 2023 MHT-specific prescription data to skeleton — x2023_mht_add_lmed","text":"function performs several steps: Restricts LMED data individuals skeleton Categorizes products MHT groups (A1-I2) based product names Applies duration fixes specific products (IUDs, minimum doses) Creates treatment approach variables based predefined logic Handles treatment gaps overlapping prescriptions","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/reference/x2023_mht_add_lmed.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Add 2023 MHT-specific prescription data to skeleton — x2023_mht_add_lmed","text":"function specific 2023 MHT study uses study-specific   categorizations approaches defined package data dictionary.","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"bug-fixes-25-12-24","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"swereg 25.12.24","text":"FIXED: Added slider package Imports DESCRIPTION fix R CMD check warning undeclared import","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"documentation-25-12-24","dir":"Changelog","previous_headings":"","what":"Documentation","title":"swereg 25.12.24","text":"FIXED: Wrapped examples add_icdo3s(), add_snomed3s(), add_snomedo10s() \\dontrun{} since functions require datasets specialized code columns (icdo3, snomed3, snomedo10) available package’s fake data","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"new-features-25-12-6","dir":"Changelog","previous_headings":"","what":"New features","title":"swereg 25.12.6","text":"Calculates number steps (e.g., weeks) first TRUE value forward-looking window Useful time--event calculations longitudinal registry data Default window 103 weeks (~2 years) customizable size Returns NA event occurs within window","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"bug-fixes-25-12-6","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"swereg 25.12.6","text":"functions now correctly call add_diagnoses_or_operations_or_cods_or_icdo3_or_snomed() functions caused runtime errors fix ICD-O editions 1, 2, 3 (10) ICD-O-3 codes handled via dedicated add_icdo3s() function Historical ICD-7 ICD-9 columns now properly searched diag_type = \"\" Validation helper function now consistent Messages now correctly reference appropriate data types instead “operation data”","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"documentation-25-12-6","dir":"Changelog","previous_headings":"","what":"Documentation","title":"swereg 25.12.6","text":"diag_type = \"\": hdia, dia*, ekod*, icd7*, icd9* diag_type = \"main\": hdia ","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"cran-submission-preparation-25-8-19","dir":"Changelog","previous_headings":"","what":"CRAN Submission Preparation","title":"swereg 25.8.19","text":"Fixed DESCRIPTION file author field duplication issue Updated .Rbuildignore exclude development files (docs/, .git/, .Rhistory, etc.) Removed non-portable files (@eaDir directories, .DS_Store files) Added missing global variable declarations prevent R CMD check warnings Verified URL consistency DESCRIPTION package startup messages Reduced total vignette content 31% (626 lines removed) Condensed cookbook-survival-analysis.Rmd (removed verbose descriptive statistics redundant sections) Simplified skeleton2-clean.Rmd (removed duplicated skeleton1_create workflow) Streamlined skeleton3-analyze.Rmd (removed redundant data loading best practices sections) Fixed vignette build errors ensuring consistent data variable availability vignettes now compile successfully use package synthetic data consistently VALIDATED: examples runnable using package fake data - \\dontrun sections without justification","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"code-quality-improvements-25-8-19","dir":"Changelog","previous_headings":"","what":"Code Quality Improvements","title":"swereg 25.8.19","text":"Updated vignettes use lowercase date_columns parameters (e.g., “indatum” instead “INDATUM”) Added warning make_lowercase_names() function uppercase date_columns provided Enhanced documentation clarify date_columns use lowercase names Improved user experience clear guidance automatic handling uppercase inputs Replaced verbose data() loading patterns elegant pipe syntax Updated data loading use swereg::fake_* |> copy() |> make_lowercase_names() pattern Eliminated clumsy multi-step data preparation code throughout vignettes Improved code flow professional appearance package examples VERIFIED: Package builds successfully R CMD build passes CRAN compliance checks CONFIRMED: inst/ directory contains files referenced package functions","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"new-features-25-7-30","dir":"Changelog","previous_headings":"","what":"New Features","title":"swereg 25.7.30","text":"Simplifies common pattern creating row-independent variables first occurrence conditions Automatically handles temp variable creation cleanup Uses first_non_na() robust aggregation across variable types Includes comprehensive input validation clear error messages Explains fundamental distinction row-dependent row-independent variables Demonstrates common transformation patterns practical examples Shows integration swereg workflow (skeleton1_create → skeleton2_clean → skeleton3_analyze) Includes best practices longitudinal registry data analysis","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"documentation-25-7-30","dir":"Changelog","previous_headings":"","what":"Documentation","title":"swereg 25.7.30","text":"ENHANCED: Helper functions now include @family data_integration tags better organization IMPROVED: Function examples use existing fake datasets consistency","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"new-swedish-date-parsing-and-enhanced-data-cleaning-25-7-16","dir":"Changelog","previous_headings":"","what":"New Swedish Date Parsing and Enhanced Data Cleaning","title":"swereg 25.7.16","text":"Handles 4-character (YYYY), 6-character (YYYYMM), 8-character (YYYYMMDD) formats Automatically replaces “0000” “0701” “00” “15” missing date components Supports custom defaults missing date parts Includes comprehensive error handling vectorized processing New date_column parameter specify column contains dates Automatically creates cleaned ‘date’ column using parse_swedish_date() Works default data.table methods Maintains backward compatibility existing code add_diagnoses(), add_operations(), add_rx(), add_cods() expect ‘date’ column Clear error messages guide users use make_lowercase_names(data, date_column = \"...\") Improved validation ensures data preprocessing consistency Annual rows (is_isoyear==TRUE) personyears = 1 Weekly rows (is_isoyear==FALSE) personyears = 1/52.25 Facilitates person-time calculations survival analysis Uses weekly data instead yearly data precise analyses Age calculation based isoyearweeksun instead isoyear Includes person-time descriptive statistics Demonstrates proper use new date cleaning workflow","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"enhanced-error-handling-and-validation-25-7-16","dir":"Changelog","previous_headings":"","what":"Enhanced error handling and validation","title":"swereg 25.7.16","text":"add_onetime(): Validates skeleton structure, ID column exists, checks ID matches add_annual(): Validates isoyear parameter, checks skeleton year coverage add_diagnoses(): Validates diagnosis patterns, checks diagnosis code columns add_operations(): Validates operation patterns, checks operation code columns add_rx(): Validates prescription data structure, checks source columns add_cods(): Validates death data structure, checks cause death columns Clear indication make_lowercase_names() forgotten Helpful suggestions column naming issues Informative ID mismatch diagnostics sample values NEW: Internal validation helper functions consistent error handling ADDED: Input validation pattern lists, data structures, parameter ranges","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"new-cookbook-documentation-25-7-16","dir":"Changelog","previous_headings":"","what":"New cookbook documentation","title":"swereg 25.7.16","text":"Complete workflow raw data Cox proportional hazards model Time-varying covariates (annual income) heart attack outcome Handles common challenges: missing data, multiple events, competing risks Performance tips large datasets Practical solutions real-world registry analysis ENHANCED: Updated _pkgdown.yml new “Cookbooks” section ADDED: survival package Suggests dependencies","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"bug-fixes-25-7-16","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"swereg 25.7.16","text":"FIXED: Improved ID matching warnings error messages across functions CORRECTED: Better handling missing data time-varying covariate analysis ENHANCED: robust parameter validation prevents common user errors","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"major-documentation-restructuring-25-7-16","dir":"Changelog","previous_headings":"","what":"Major documentation restructuring","title":"swereg 25.7.16","text":"NEW “Skeleton concept” vignette: Conceptual foundation explaining skeleton approach without technical implementation “Building data skeleton (skeleton1_create)”: Pure data integration focus - raw data time-structured skeleton “Cleaning deriving variables (skeleton2_clean)”: Pure data cleaning variable derivation focus “Production analysis workflows (skeleton3_analyze)”: Memory-efficient processing final analysis datasets IMPROVED: Clear separation concerns focused, single-purpose tutorials ENHANCED: Systematic learning progression concept implementation production UPDATED: _pkgdown.yml structure logical vignette grouping PRESERVED: existing technical content improving organization","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"content-improvements-25-7-16","dir":"Changelog","previous_headings":"","what":"Content improvements","title":"swereg 25.7.16","text":"NEW: Comprehensive conceptual introduction based presentation content IMPROVED: vignette builds systematically previous one ENHANCED: Better explanation three types data integration (one-time, annual, event-based) CLARIFIED: Production workflow patterns memory-efficient batching strategies STANDARDIZED: Consistent academic tone sentence case throughout","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"documentation-and-presentation-improvements-25-7-15","dir":"Changelog","previous_headings":"","what":"Documentation and presentation improvements","title":"swereg 25.7.15","text":"Vignette titles: “Basic Workflow” → “Basic workflow”, “Complete Workflow” → “Complete workflow”, etc. README.md section headings: “Core Functions” → “Core functions”, “Data Integration” → “Data integration”, etc. NEWS.md section headings: “Vignette Restructuring” → “Vignette restructuring”, etc. CLAUDE.md section headings: “Project Overview” → “Project overview”, “Development Commands” → “Development commands”, etc. IMPROVED: Consistent normal sentence case better readability less formal appearance SIMPLIFIED: Removed subtitle text colons vignette titles cleaner presentation One-time data (demographics): Added rows person Annual data (income, family status): Added rows specific year Event-based data (diagnoses, prescriptions, deaths): Added rows events occurred CLARIFIED: Step 1 documentation now properly explains skeleton columns including isoyearweeksun VERIFIED: vignettes compile successfully improved content","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"major-documentation-and-vignette-reorganization-25-7-15","dir":"Changelog","previous_headings":"","what":"Major documentation and vignette reorganization","title":"swereg 25.7.15","text":"swereg.Rmd → basic-workflow.Rmd: Focused introduction skeleton1_create advanced-workflow.Rmd → complete-workflow.Rmd: Two-stage workflow (skeleton1_create + skeleton2_clean) memory-efficient-batching.Rmd: Maintained comprehensive three-stage workflow guide IMPROVED: Eliminated content redundancy vignettes clearer learning progression ENHANCED: Updated _pkgdown.yml configuration reflect new vignette structure","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"function-documentation-improvements-25-7-15","dir":"Changelog","previous_headings":"","what":"Function documentation improvements","title":"swereg 25.7.15","text":"Added @family tags logical grouping (data_integration, skeleton_creation, data_preprocessing) Added @seealso sections cross-references related functions vignettes Replaced placeholder examples runnable code using synthetic data Improved parameter documentation detailed descriptions expected formats Enhanced return value documentation explicit side effects description STANDARDIZED: Consistent academic tone throughout documentation","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"professional-presentation-updates-25-7-15","dir":"Changelog","previous_headings":"","what":"Professional presentation updates","title":"swereg 25.7.15","text":"IMPROVED: Removed informal elements adopted academic tone across documentation UPDATED: Changed terminology “fake data” “synthetic data” throughout ENHANCED: professional language README.md vignettes STANDARDIZED: Consistent formal tone appropriate scientific software","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"technical-improvements-25-7-15","dir":"Changelog","previous_headings":"","what":"Technical improvements","title":"swereg 25.7.15","text":"VERIFIED: vignettes compile successfully updated content TESTED: Package passes R CMD check documentation improvements UPDATED: CLAUDE.md reflects new vignette structure documentation standards","code":""},{"path":[]},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"vignette-restructuring-25-7-1","dir":"Changelog","previous_headings":"","what":"Vignette restructuring","title":"swereg 25.7.1","text":"swereg.Rmd: Clean skeleton1_create tutorial using full datasets (removed subset filtering) advanced-workflow.Rmd: Focused skeleton1→skeleton2 workflow (removed batching skeleton3 content) memory-efficient-batching.Rmd: NEW comprehensive batching vignette complete skeleton1→skeleton2→skeleton3 workflow large-scale studies IMPROVED: GitHub Actions workflow optimization dependency caching binary packages faster CI/CD","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"batching-vignette-fixes-25-7-1","dir":"Changelog","previous_headings":"","what":"Batching vignette fixes","title":"swereg 25.7.1","text":"Replace split() csutil::easy_split better batch handling Replace saveRDS/readRDS qs::qsave/qread 2-10x faster file /O Fix skeleton3_analyze properly aggregate weekly→yearly data using swereg::max_with_infinite_as_na Remove incorrect is_isoyear == TRUE filter skeleton3_analyze Fix analysis results avoid NaN outputs treatment rate calculations Add explanations weekly→yearly data aggregation qs package performance benefits","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"new-features-25-7-1","dir":"Changelog","previous_headings":"","what":"New features","title":"swereg 25.7.1","text":"NEW: Added isoyearweeksun variable create_skeleton() function - provides Date representing Sunday (last day) ISO week/year easier date calculations NEW: Updated package logo IMPROVED: Updated vignettes assume swereg loaded - functions use swereg:: prefix data() calls use package=\"swereg\" argument IMPROVED: Updated function documentation clarify pattern matching functions (add_diagnoses, add_cods, add_rx) automatically add “^” prefix - users include “^” patterns fake_person_ids: 1000 synthetic personal identifiers fake_demographics: Demographics data matching SCB format fake_annual_family: Annual family status data fake_inpatient_diagnoses fake_outpatient_diagnoses: NPR diagnosis data ICD-10 codes fake_prescriptions: LMED prescription data ATC codes hormone therapy focus fake_cod: Cause death data swereg.Rmd: Basic skeleton1_create workflow tutorial advanced-workflow.Rmd: Complete 3-phase workflow (skeleton1 → skeleton2 → skeleton3) NEW: Replaced magrittr pipe (%>%) base pipe (|>) throughout codebase NEW: Added memory-efficient batched processing examples large registry studies","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"bug-fixes-25-7-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"swereg 25.7.1","text":"CRITICAL: Fixed incorrect variable names fake_cod dataset - changed non-Swedish underlying_cod/contributory_cod1/contributory_cod2 correct Swedish registry names ulorsak/morsak1/morsak2 VERIFIED: Confirmed fake datasets use correct Swedish registry variable name conventions VERIFIED: ICD-10 ATC codes fake datasets properly formatted realistic","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"documentation-improvements-25-7-1","dir":"Changelog","previous_headings":"","what":"Documentation improvements","title":"swereg 25.7.1","text":"BREAKING: Fixed incorrect function descriptions copied another package add_onetime(): Documents merging one-time/baseline data skeleton add_annual(): Documents merging annual data specific ISO years add_cods(): Documents cause death analysis ICD-10 codes add_diagnoses(): Documents diagnosis analysis main/secondary diagnoses add_operations(): Documents surgical operation analysis including gender-affirming procedures add_rx(): Documents prescription drug analysis ATC/product codes create_skeleton(): Documents longitudinal skeleton creation detailed return structure make_lowercase_names(): Documents generic function S3 methods x2023_mht_add_lmed(): Documents specialized MHT study function min_with_infinite_as_na(), max_with_infinite_as_na() as_logical_min_with_infinite_as_na(), as_logical_max_with_infinite_as_na() first_non_na(), last_non_na() NEW: Added @param descriptions function parameters NEW: Added @return descriptions explaining function outputs NEW: Added @examples practical usage demonstrations NEW: Added @details @note sections complex functions IMPROVED: Used proper roxygen2 practices including @rdname S3 methods @seealso cross-references","code":""},{"path":"https://papadopoulos-lab.github.io/swereg/news/index.html","id":"package-structure-25-7-1","dir":"Changelog","previous_headings":"","what":"Package structure","title":"swereg 25.7.1","text":"exported functions now complete, accurate documentation suitable CRAN submission Documentation focuses Swedish registry data analysis workflows Examples use \\dontrun{} appropriately functions requiring external data","code":""}]
